e{% extends 'base.html' %}
{% load static %}
{% load custom_tags %}

{% block extra_head %}

<script type="text/javascript"  src="https://cdnjs.cloudflare.com/ajax/libs/jquery.textcomplete/1.8.0/jquery.textcomplete.js"></script>
<script type="text/javascript" src="{% static 'js/jquery-comments.js' %}"></script>

{#<script type="text/javascript" src="https://unpkg.com/markerjs2/markerjs2.js"></script>#}
<script src="https://unpkg.com/@markerjs/markerjs3/umd/markerjs3.js"></script>
{#<script src="https://unpkg.com/@markerjs/markerjs-ui/markerjs-ui.umd.cjs"></script>#}

<script type="text/javascript" src="{% static 'js/jspolygon.js' %}"></script>

<!-- MathJax -->
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js">
</script>
<link rel="stylesheet" type="text/css" href="{% static 'css/jquery-comments.css' %}">
<link rel="stylesheet" type="text/css" href="{% static 'css/styleMarkerjs.css' %}">

{% endblock %}

{% block title %}Review {{ pages_group }}{% endblock %}
{% block scripts %}
{% endblock %}

{% block content %}
{% if user.pk|is_review_blocked:exam_selected.pk %}
    <div class="alert alert-warning" role="alert">
        You are currently blocked for Review! <br><br> Please contact the teacher to be unblocked.
    </div>
{% else %}
    {%  if copies_pages_list %}
    <div class="row" style="height:50px;">
        <div class="column" style="width:300px;margin-left:15px;">
            <a href="{% url 'reviewView' exam_selected.pk %}" class="btn btn-outline-dark btn-sm"><i class="fas fa-arrow-left fa-lg" style="margin-right:10px;"></i>Back to Summary</a>
        </div>
        <div class="column" style="margin-left:50px;">
            <h3><i class="fas fa-glasses fa-l" style="margin-right:10px;"></i>Review {{ pages_group.group_name }}</h3>
        </div>
    </div>
        <div>

        </div>
    <style>
    :focus { outline: none; }
    </style>
    <div id="reviewGroup_div" class="d-flex" tabindex="0" style="height:92vh;">


        <div id="pages_group_list" style="background-color:#f1f1f1;">
            <a id="expandCollapseGroupListBt" type="button" data-bs-toggle="collapse" style="margin:5px 5px 5px 5px;float:right;" data-bs-target="#pages_group_list_table_div" aria-expanded="True" aria-controls="pages_group_list_table_div">
                <i id="expand-group-list-icon" class="fa-lg" style="color:grey;"></i>
                <i id="collapse-group-list-icon" class="fa mr-3 fa-angle-double-left" style="color:grey;"></i>
            </a>
            <div id="pages_group_list_table_div" class="collapse collapse-horizontal show">
                <table class="table table-striped table-sm" id="table-copies-pages">
                    <thead>
                    <tr>
                        <th></th>
                        <th>id</th>
                        <th>Copy</th>
                        <th>Page</th>
                        <th>Graded</th>
                        <th></th>
                    </tr>
                    </thead>
                    <tbody>
                    {% for page in copies_pages_list %}
                    <tr id="copy_{{page.copy_no}}_{{page.page_no}}">
                        <td>
                            <i id="copy_{{page.copy_no}}_{{page.page_no}}_id" name="{{ forloop.counter }}" class="fa-solid fa-lock fa-xs" style="display:None; color: #df8134;"></i>
                        </td>
                        <td style="text-align:left;">
                            {{ forloop.counter }}
                        </td>
                        <td style="text-align:left;">{{ page.copy_no }}</td>
                        <td style="text-align:center;">{{ page.page_no }}</td>
                        <td id="copy_{{page.copy_no}}_{{page.page_no}}_marked" >{% if page.marked %}<i class="fa-solid fa-circle-check fa-lg"
                                                   style="padding-left:25px;">{% endif %}</i></td>
                        <td>
                            {% if page.comment %}
                            <i class="fas fa-comments fa-lg"></i>
                            {% endif %}
                        </td>
                    </tr>
                    {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
        <div class="list-group" id="review-center-div" style="height:100%;margin-left:5px;width:60vw;position:relative;" >
            <div id="pagination" class="list-group list-group-horizontal"></div>
            <div id="copy_page_select" style="z-index:99;position:absolute;margin-top:100px;right:20px;background-color: gray;padding:2px;"></div>
            <div id="markerjs_div">
                <div id="mjs-toolbar" class="markerjs-toolbar d-flex">
                    <div class="toolbar-left d-flex">
                        <button type="button" class="btn btn-light" id="btn-clear"><i class="fa-solid fa-broom fa-lg"></i></button>
                        <button type="button" class="btn btn-light" id="btn-undo"><i class="fa-solid fa-arrow-rotate-left fa-lg"></i></button>
                        <button type="button" class="btn btn-light" id="btn-redo"><i
                                class="fa-solid fa-arrow-rotate-right fa-lg"></i>
                        </button>
                    </div>
                    <div id="mjs-toolbar-center" class="toolbar-center d-flex">
                        <button type="button" class="btn btn-light" id="btn-pointer"><i
                                class="fa-solid fa-arrow-pointer fa-lg"></i></button>
                        <button type="button" class="btn btn-light" id="btn-text-marker"><i class="fa-solid fa-t fa-lg"></i></button>
                        <button type="button" class="btn btn-light" id="btn-freehand-marker">
                            <i class="fa-solid fa-s fa-lg" style="margin-top:10px;transform:scaleY(-1) rotate(55deg);"></i>
                            <i class="fa-solid fa-pencil fa-lg" style="margin-left:0px;"></i>
                        </button>
                    </div>
                    <div class="toolbar-right d-flex">
                        <p id="magnify-help" class="text-muted small d-none">
                          Tip: click outside the image to stop magnifying.
                        </p>
                        <button type="button" class="btn btn-light" id="btn-magnify"><i class="fa-solid fa-magnifying-glass-plus fa-lg"></i></button>
                    </div>
                </div>
                <div id="mjsapp" class="col-xs-6">
                    <div id ="marker-wrapper">
                        <div id="corr_box_div" class="corr-box-div"></div>
                    </div>
                </div>
                <div id="mjs-bottom-bar" class="markerjs-bottom-bar">
                    <div class="color-picker-wrapper">
                        <button type="button" class="btn btn-light" id="btn-color"><i class="fa-solid fa-palette fa-lg"></i></button>

                        <input type="color"
                           class="form-control form-control-color"
                           id="color-input"
                           value="#CCCCCC"
                           title="Choose a color"
                           style="position:absolute; left:-9999px; width:0; height:0; opacity:0;">
                    </div>
                </div>
            </div>
        </div>
        <div style="height:100%;">
            <p style="margin-right:20px;margin-top:10px;">
                <a title="Discussion"
                   class="js-toggle-comments"
                   type="button"
                   data-bs-toggle="modal"
                   style="float:right;"
                   data-bs-target="#commentsModal"
                   aria-expanded="false"
                   aria-controls="comments-div">
                    <i id="comment-icon" class="fas fa-comments fa-2x" style="margin-left:10px;"></i>
                </a>
            </p>
            {% if pages_group.use_grading_scheme %}
                <div id="grading-scheme-div" style="height:100%;background-color:#f1f1f1;padding:5px;padding-top:10px;margin-top:-19px;">
                    <h6>Grading Schemes</h6>

                    <ul class="nav nav-pills flex-column flex-md-row border" id="review-scheme-pills">
                        {% for gs in grading_schemes %}
                            <li class="nav-item" role="presentation">
                                <a type="button"
                                   id="review-scheme-link-{{ gs.id }}"
                                   class="nav-link js-scheme-link {% if current_grading_scheme and current_grading_scheme.id == gs.id %}active{% endif %}"
                                   aria-selected="{% if current_grading_scheme and current_grading_scheme.id == gs.id %}true{% else %}false{% endif %}"
                                   data-exam-id="{{ exam_selected.id }}"
                                   hx-trigger="never"
                                   data-hx-get="{% url 'review_grading_scheme_panel' exam_selected.id gs.id 0 %}"
                                   onclick="return sendScheme(this, event)">
                                    {{ gs.name }}
                                </a>
                            </li>
                        {% endfor %}
                    </ul>
                    <div id="review-scheme-panel" class="tab-content"></div>
                </div>
            {% endif %}
        </div>
    </div>
        <div class="modal" id="commentsModal" tabindex="-1" aria-labelledby="commentsModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg modal-dialog-scrollable">
                <div class="modal-content">
                    <div class="modal-header handle">
                        <h5 class="modal-title" id="commentsModalLabel">
                            <i class="fas fa-comments fa-lg"></i> Discussion
                        </h5>
                    </div>
                    <div class="modal-body p-0">
                        <div id="comments-container" style="padding:5px;"></div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>

    <script>
        let targetRoot, maState, markedImageDataUrl,currSourceElementId, currSourceIdSplit,from_copy_orig_id;
        let group_copies_pages_list = JSON.parse('{{json_copies_pages_list|safe }}');
        let current_grading_scheme_id;
        let corrector_boxes_data;
        let magnifierActive = false;
        let destroyMagnifierFn = null;

        //MSJ3_ Global markerjs3 object
        const { MarkerArea, FreehandMarker, TextMarker, HighlightMarker, MarkerView, Renderer } = markerjs3;
        const mjs3App = document.querySelector("#mjsapp");
        const wrapper = document.querySelector("#marker-wrapper");
        let markerArea = new MarkerArea();
        wrapper.appendChild(markerArea);
        let sourceImage = new Image();
        let selectedMarkerEditor = null

        //source image on load resize
        sourceImage.onload = () => {
            sourceImage_onload();
        };

        $('.modal-dialog').draggable();

        window.MathJax = {
            tex: {
                inlineMath: [['$$', '$$'], ['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],

            }
        };

        window.addEventListener('resize', function (event) {
            location.reload();
        }, true);

        function showBottomBar(show) {
            document.getElementById('mjs-bottom-bar').classList.toggle('show', show);
        }

        function sourceImage_onload(){
            // Attach image to markerArea
            markerArea.targetImage = sourceImage;

            // Append markerArea once
            if (!mjs3App.contains(markerArea)) {
                mjs3App.appendChild(markerArea);
            }
            // Measure available space
            const rect = mjs3App.getBoundingClientRect();

            const imgW = sourceImage.naturalWidth;
            const imgH = sourceImage.naturalHeight;
            const imageRatio = imgW / imgH;

            let targetWidth, targetHeight;

            targetWidth  = rect.width-20;
            targetHeight = targetWidth / imageRatio;

            markerArea.targetWidth  = targetWidth;
            markerArea.targetHeight = targetHeight;

            $("#corrector_boxes_svg").empty();
            if (corrector_boxes_data.length > 0) {
                draw_corrector_boxes();
            }
        }

        // save references to the original image and its parent div (positioning root)
        function setSourceImage(source) {
            sourceImage = source;
            targetRoot = source.parentElement;
        }

        function createPagination(pages, page) {


            let str = '';

            // Show the Previous button only if you are on a page other than the first
            if (page > 1) {
                str += '<a id="previous_page" class="list-group-item list-group-item-action" onclick="createPagination(' + pages + ', ' + (page - 1) + ')">Previous</a>';
            }

            // Show the very first page followed by a "..." at the beginning of the
            // pagination section (after the Previous button)
            if (page > 1) {
                str += '<a class="list-group-item list-group-item-action" onclick="createPagination(' + pages + ', 1)">1</a>';
                if (page > 2) {
                    str += '<a class="list-group-item list-group-item-action" onclick="createPagination(' + pages + ',' + (page - 2) + ')">...</a>';
                }
            }
            // Determine how many pages to show after the current page index
            if (page === 1) {
                <!-- pageCutHigh += 1; -->
            } else if (page === 2) {
                <!-- pageCutHigh += 0; -->
            }
            // Determine how many pages to show before the current page index
            if (page === pages) {
                <!-- pageCutLow -= 1; -->
            } else if (page === pages - 1) {
                <!-- pageCutLow -= 0; -->
            }
            // active page
            str += '<a class="list-group-item list-group-item-action active" onclick="createPagination(' + pages + ', ' + page + ')">' + page + '</a>';

            // Show the very last page preceded by a "..." at the end of the pagination
            // section (before the Next button)
            if (page < pages - 1) {
                if (page < pages - 2) {
                    str += '<a class="list-group-item list-group-item-action" onclick="createPagination(' + pages + ',' + (page + 2) + ')">...</a>';
                }
                str += '<a class="list-group-item list-group-item-action" onclick="createPagination(' + pages + ',' + pages + ')">' + pages + '</a>';
            }
            // Show the Next button only if you are on a page other than the last
            if (page < pages) {
                str += '<a id="next_page" class="list-group-item list-group-item-action" onclick="createPagination(' + pages + ',' + (page + 1) + ')">Next</a>';
            }

            // Return the pagination string to be outputted in the pug templates
            document.getElementById("pagination").innerHTML = str;

            copy_no = group_copies_pages_list[page - 1]["copy_no"];
            page_no = group_copies_pages_list[page - 1]["page_no"];
            if (setMarkerArea(copy_no, page_no)) {
                // hide HiglightMarker if visible (marker used for corrector boxes but not available for reviewers
                hl_marker_elements = document.querySelectorAll('[data-type-name="HighlightMarker"]');
                for (el of hl_marker_elements) {
                    el.style = "display:none;";
                }
            } else {
                if (page < pages) {
                    createPagination(pages, page + 1);
                } else {
                    createPagination(pages, 1);
                }
            }
        }

        function setSourceScan(scan_path, from_copy) {

            if (from_copy) {
                lastSourceIdSplit = old_source.split('_');
                from_copy_orig_id = lastSourceIdSplit[0] + "_" + lastSourceIdSplit[1] + "_" + lastSourceIdSplit[2];
            }
            src_url = "/" + scan_path.split('/')[1] + "/" + scan_path.split('/')[3];

            old_source = sourceImage.alt;
            sourceImage.src = src_url;
            sourceImage.alt = scan_path.split("/")[2];

            // change current and last source element background color
            currSourceIdSplit = scan_path.split("/")[2].split('_');
            //currSourceIdSplit = scan_path.replace(/\/+$/, '').split('/').pop().split('.jpg')[0].split('_');
            currSourceElementId = currSourceIdSplit[0] + "_" + currSourceIdSplit[1] + "_" + currSourceIdSplit[2];

            if (!from_copy) {
                currEl = document.getElementById(currSourceElementId)
                currSourceIdSplit.push(document.getElementById(currSourceElementId).cells[0].innerText);
            }
            if (old_source && !from_copy) {
                if (from_copy_orig_id !== null) {
                    lastSourceElementId = from_copy_orig_id;
                    from_copy_orig_id = null;
                } else {
                    lastSourceElementId = old_source;
                }

                lastEl = document.getElementById(lastSourceElementId);
                if (lastEl) {
                    lastEl.style.backgroundColor = "";
                }
            }
            if (!from_copy) {
                document.getElementById(currSourceElementId).style.backgroundColor = "yellow";
            }

        }

        // --- helper to sync from current editor to UI ---
        function syncColorUIFromEditor(editor) {
            if (!editor) return;

            let color = null;

            // shapes, lines, freehand, polygon → use strokeColor (like in docs)
            if ('strokeColor' in editor && editor.strokeColor) {
                color = editor.strokeColor;
            }
            // text markers → color is on editor.marker.color
            if (!color && editor.marker && 'color' in editor.marker && editor.marker.color) {
                color = editor.marker.color;
            }

            if (!color) return;

            // update color picker and button
            document.getElementById('color-input').value = color;
        }
        // send back to marker selected color
        document.getElementById('color-input').addEventListener('input', (ev) => {
            const editor = markerArea.currentMarkerEditor;
            if (!editor) return;

            const newColor = ev.target.value;

            // for markers with strokeColor (lines, freehand, shapes…)
            if ('strokeColor' in editor) {
                editor.strokeColor = newColor;
            }

            // for text markers
            if (editor.marker && 'color' in editor.marker) {
                editor.marker.color = newColor;
            }

        });

        function updateMarkerToolbarSelection() {
            const buttons = document.querySelectorAll('#mjs-toolbar-center .btn');
            buttons.forEach(btn => btn.classList.remove('active'));

            switch (selectedMarkerEditor) {
                case 'TextMarker':
                    document.getElementById('btn-text-marker').classList.add('active');
                    showBottomBar(true);
                    break;
                case 'FreehandMarker':
                    document.getElementById('btn-freehand-marker').classList.add('active');
                    showBottomBar(true);
                    break;
                default:
                    document.getElementById('btn-pointer').classList.add('active');
                    showBottomBar(false);
            }
        }

        function generate_marker_toolbar_button_events() {
            document.getElementById('btn-text-marker').addEventListener('click', function () {
                markerArea.createMarker("TextMarker");
                selectedMarkerEditor = "TextMarker";
                updateMarkerToolbarSelection();
            });

            document.getElementById('btn-freehand-marker').addEventListener('click', function () {
                markerArea.createMarker("FreehandMarker");
                selectedMarkerEditor = "FreehandMarker";
                updateMarkerToolbarSelection();
            });

            document.getElementById('btn-pointer').addEventListener('click', function () {
                markerArea.switchToSelectMode();
                selectedMarkerEditor = null;
                updateMarkerToolbarSelection();
            });

            document.getElementById('btn-clear').addEventListener('click', function () {
                const currentState = markerArea.getState();
                currentState.markers = currentState.markers.filter(
                    m => m.typeName === 'HighlightMarker'
                );
                markerArea.restoreState(currentState);
                // force marker area to re-layout and redraw using the updated state
                sourceImage_onload();
                    markerChange();
            });

            document.getElementById('btn-undo').addEventListener('click', function () {
                if (markerArea.isUndoPossible) {
                    markerArea.undo();
                    markerChange();
                }
            });

            document.getElementById('btn-redo').addEventListener('click', function () {
                if (markerArea.isRedoPossible) {
                    markerArea.redo();
                    markerChange();
                }
            });

            // bottom bar buttons
            document.getElementById('btn-color').addEventListener('click', (e) => {
                e.stopPropagation(); // prevent immediate close from document click
                document.getElementById('color-input').click();
            });

            document.getElementById('color-input').addEventListener('input', () => {
                const color = document.getElementById('color-input').value;
                console.log('Selected color:', color);
                // Apply it to your marker / text / whatever:
                // setMarkerColor(color);
            });

            // event for keyboard delete to remove selected marker
            document.addEventListener('keydown', function (e) {

                if (e.key === 'Delete') {
                    // If you want to avoid deleting when user is typing in an input/textarea:
                    const tag = document.activeElement && document.activeElement.tagName;
                    if (tag === 'INPUT' || tag === 'TEXTAREA') {
                        return; // don't delete markers while typing in a field
                    }

                    // This will remove all currently selected markers
                    markerArea.deleteSelectedMarkers();

                    // optional: prevent default browser behavior
                    e.preventDefault();
                }
            });

            // marker deselect and and delete event listener
            markerArea.addEventListener('markerdeselect', (ev) => {
                if (selectedMarkerEditor === ev.detail.markerEditor.marker.typeName) {
                    selectedMarkerEditor = null;
                    showBottomBar(false);
                }
                markerChange();
            });

            markerArea.addEventListener("markerdelete", (event) => {
                markerChange();
                showBottomBar(false);
            });

            markerArea.addEventListener('markerselect', (e) => {
              syncColorUIFromEditor(e.detail.markerEditor);
              selectedMarkerEditor = e.detail.markerEditor.marker.typeName;
              showBottomBar(true);
            });

            markerArea.addEventListener('markercreate', (e) => {
              syncColorUIFromEditor(e.detail.markerEditor);
            });

            markerArea.addEventListener('markerchange', (e) => {
              syncColorUIFromEditor(e.detail.markerEditor);
            });

        }

        function setMarkerArea(copy_no, page_no, from_copy = false) {
            //MJS3_
            wrapper.removeChild(markerArea)
            markerArea = new MarkerArea();
            wrapper.appendChild(markerArea);
            generate_marker_toolbar_button_events();
            updateMarkerToolbarSelection();

            getMarkersAndComments("{{ exam_selected.pk }}", copy_no, page_no, from_copy);//,sourceImage.getAttribute("src"));#}

            //get Markers (state) if exist
            imgsrc_split = sourceImage.src.split('/').pop().split('.').slice(-2)[0].split('_');
            copy_no = currSourceIdSplit[1];
            page_no = currSourceIdSplit[2];
            if(result) {
                // if previous state is present - restore it
                if (maState) {
                    markerArea.restoreState(maState);
                }

                return true;
            }else{
                return false;
            }

        }

        async function markerChange() {
            // Create renderer
            const renderer = new Renderer();

            // 2. Use the same image as for MarkerArea
            renderer.targetImage = markerArea.targetImage;

            // full natural size + JPEG
            renderer.naturalSize = true;
            renderer.imageType = 'image/jpeg';

            // Rasterize current annotation state to a data URL
            const dataUrl = await renderer.rasterize(markerArea.getState());

            markedImageDataUrl = dataUrl;
            updateMarkers(markerArea, "{{ exam_selected.pk }}", "{{ pages_group.pk }}");
        }

        function initCopyPagesSelectpicker(pages, curr_page) {
            const selectElDiv = document.getElementById('copy_page_select');
            selectElDiv.innerHTML = "";
            const selectEl = document.createElement('select');
            selectEl.className = 'selectpicker form-control';
            selectEl.style.width = '100px'
            pages.forEach(pageData => {
                const optionEl = document.createElement('option');
                optionEl.value = pageData.copy_no + "-" + pageData.page_no;
                optionEl.textContent = "page " + pageData.page_no;
                if (Number(curr_page) === Number(pageData.page_no)) {
                    optionEl.selected = true;
                }
                selectEl.appendChild(optionEl);
            })
            selectEl.addEventListener('change', () => {
                copy_nr = selectEl.value.split('-')[0]
                page_nr = selectEl.value.split('-')[1]
                changeCopyPage({{ pages_group.exam.pk }}, copy_nr, page_nr);
            });
            selectElDiv.append(selectEl);
            $('.selectpicker').selectpicker();
        }

        function changeCopyPage(exam_pk, copy_no, page_no) {
            $.ajax({
                url: "{% url 'get_copy_page' exam_selected.pk %}",
                type: "POST",
                data: {
                    'csrfmiddlewaretoken': "{{ csrf_token }}",
                    'copy_no': copy_no,
                    //'curr_row': curr_row,
                    'page_no': page_no,
                },
                success: (copyPageUrl) => {
                    setMarkerArea(copy_no, page_no, true);
                },
            });
        }

        function getMarkersAndComments(pk, copy_no, page_no, from_copy = false) {
            result = false;
            var markers;
            $.ajax({
                url: "{% url 'review_student_pages_group_is_locked' exam_selected.pk %}",
                async: false,
                type: "POST",
                data: {
                    'csrfmiddlewaretoken': "{{ csrf_token }}",
                    'pages_group_id': {{ pages_group.id }},
                    'copy_no': copy_no,
                },
                success: (data) => {
                    if (data === '') {
                        td_el = document.getElementById('copy_' + copy_no + '_' + Number(page_no) + '_id');
                        if (td_el) {
                            td_el.style.display = 'None';
                        }
                        //td_el = document.getElementById('copy_'+copy_no+'_'+Number(page_no)+'_id');
                        //td_el.innerText=td_el.getAttribute('name');
                        $.ajax({
                                url: "{% url 'get_markers_and_comments' exam_selected.pk %}",
                                async: false,
                                type: "POST",
                                data: {
                                    'csrfmiddlewaretoken': "{{ csrf_token }}",
                                    'copy_no': copy_no,
                                    'page_no': "" + page_no,
                                    //'filename' : filename,
                                    'group_id': {{ pages_group.id }}
                                },
                                success: (data) => {
                                    markers = "None";
                                    if (data != "None") {
                                        data_full = JSON.parse(data);

                                        setSourceScan(data_full.copyPageUrl, from_copy);

                                        maState = JSON.parse(data_full.markers);
                                        comments = data_full.comments;
                                        corrector_boxes_data = JSON.parse(data_full.corrector_boxes);
                                        initComments(comments);
                                        pages = JSON.parse(data_full.copy_pages);
                                        initCopyPagesSelectpicker(pages, page_no);

                                        //Refresh grading scheme panel
                                        const active = document.querySelector('a[id^="review-scheme-link-"].active') || document.querySelector('a[id^="review-scheme-link-"]');
                                        if (active) {
                                            setTimeout(() => sendScheme(active), 0);
                                        }

                                    }
                                    result = true;
                                },
                                error: (error) => {
                                    console.log(error);
                                }
                            }
                        );
                    } else {
                        td_el = document.getElementById('copy_' + copy_no + '_' + Number(page_no) + '_id');
                        td_el.style.display = 'block';// '<i class="fa-solid fa-lock" style="color: #df8134;"><a style="font-weight: normal;color:#626262;">'+td_el.getAttribute('name')+'<\i>';
                        //td_el.innerHTML=inner_html;
                        result = false;
                    }

                },
                    error:
                        (error) => {
                            console.log(error);
                        }
                }
            )
            return result;
        }

        function draw_corrector_boxes() {
            const svgns = 'http://www.w3.org/2000/svg';

            // image ratio and positions for div
            imgScale = markerArea.targetWidth / sourceImage.naturalWidth  ?? sourceImage.naturalWidth;
            imgScale = imgScale * markerArea.zoomLevel;

            // --- 2. Find bounds in ORIGINAL coordinates ---
            const xs = corrector_boxes_data.map(p => p.x);
            const ys = corrector_boxes_data.map(p => p.y);

            const min_x = Math.min(...xs);
            const max_x = Math.max(...xs);
            const min_y = Math.min(...ys);
            const max_y = Math.max(...ys);

            // position (in DISPLAY coordinates)
            const x_pos = min_x * imgScale;
            const y_pos = min_y * imgScale;//+toolbar_height;
            const corrBox_margin = 10;

            // check for the div

            let corrBoxDiv = document.getElementById('corr_box_div');
            corrBoxDiv.id = 'corr_box_div';
            corrBoxDiv.style.position = 'absolute';
            corrBoxDiv.style.zIndex = '988';
            corrBoxDiv.style.width = '75%';
            corrBoxDiv.style.height = `${(max_y - min_y) * imgScale}px`;
            corrBoxDiv.style.left   = `${x_pos}px`;
            corrBoxDiv.style.top    = `${y_pos}px`;
            corrBoxDiv.style.margin = `${corrBox_margin}px`;


            // check for the svg inside the div
            let corrector_boxes_svg = corrBoxDiv.querySelector('#corrector_boxes_svg');
            if (!corrector_boxes_svg) {
                corrector_boxes_svg = document.createElementNS(svgns, 'svg');
                corrector_boxes_svg.id = 'corrector_boxes_svg';
                corrector_boxes_svg.setAttribute('style', 'width:100%;height:100%;');

                corrBoxDiv.appendChild(corrector_boxes_svg);
            }

            let pos_y_min = 0;
            let pos_y_max = 0;

            let polygon = null;
            let pol_left = 0;
            let pol_top = 0;
            let pol_width = 0;
            let pol_height = 0;

            for (let pos of corrector_boxes_data) {
                if (pos.y > pos_y_max) {
                    pos_y_max = pos.y;
                } else if (pos_y_min === 0 || pos.y < pos_y_min) {
                    pos_y_min = pos.y;
                }

                if (pos.corner === 1) {
                    pol_left = pos.x * imgScale;
                    pol_top = pos.y * imgScale;
                    polygon = document.createElementNS(svgns, 'polygon');
                }

                if (polygon) {
                    var point = corrector_boxes_svg.createSVGPoint();
                    point.x = pos.x * imgScale - x_pos ;
                    point.y = pos.y * imgScale - y_pos ;
                    polygon.points.appendItem(point)
                }

                if (pos.corner === 2) {
                    pol_width = (pos.x * imgScale ) - pol_left;
                }

                if (pos.corner === 4 && polygon) {
                    pol_height = (pos.y * imgScale ) - pol_top;
                    corrector_boxes_svg.appendChild(polygon);
                    polygon.setAttribute('fill', 'transparent');
                    polygon.setAttribute('stroke', 'purple');
                    polygon.setAttribute('stroke-width', '3');
                    polygon.setAttribute('opacity', '0.7');
                    polygon.setAttribute('data-bounds', pol_left + "," + pol_top + "," + pol_width + "," + pol_height);
                    if ('{{ pages_group.use_grading_scheme }}' !== 'True') {
                        polygon.setAttribute('onclick', "createMarker4CorrBox(" + pol_left + "," + pol_top + "," + pol_width + "," + pol_height + ");");
                    }

                    polygon = null
                }
            }
            corr_height = max_y * imgScale - y_pos + 1;
        }

        function createMarker4CorrBox(left, top, width, height) {
            // Get current state snapshot
            const state = markerArea.getState();
            const markers = state.markers ? [...state.markers] : [];

            let pushMarker = true;

            // Remove existing HighlightMarker and decide whether to push a new one
            for (let i = markers.length - 1; i >= 0; i--) {
                const m = markers[i];
                if (m.typeName === 'HighlightMarker') {
                    pushMarker = false;

                    if (
                        left !== -1 &&
                        (m.left !== left ||
                            m.top !== top ||
                            m.width !== width ||
                            m.height !== height)
                    ) {
                        pushMarker = true;
                    }

                    // remove old highlight marker from the array
                    markers.splice(i, 1);
                }
            }

            // 3. If needed, add a new HighlightMarker
            if (pushMarker && left !== -1) {
                const newMarkerState = {
                    typeName: 'HighlightMarker',
                    left: left,
                    top: top,
                    width: width,
                    height: height,
                    fillColor: 'black',
                    opacity: 1,
                    rotationAngle: 0,
                };

                markers.push(newMarkerState);
            }

            // 4. Apply the new markers array and redraw
            const newState = {
                ...state,
                markers: markers
            };

            markerArea.restoreState(newState);
            markerChange();

        }

        function initCopyPagesTableOnClickRowEvent(refresh) {

            $("#table-copies-pages").off().on('click', 'tr', function () {
                createPagination({{ copies_pages_list|length }}, parseFloat(this.cells[1].innerText));
            });

            if (!refresh) {
                var table = $("#table-copies-pages").DataTable({
                    scrollY: '80vh',
                    "dom": 'rtip',
                    "lengthChange": false,
                    "paging": false,
                });
            }
        }


        function updateMarkers(markerArea, exam_pk, pages_group_pk) {
            imgsrc_split = sourceImage.src.split('/').pop().split('.').slice(-2)[0].split('_');
            copy_no = currSourceIdSplit[1];
            page_no = currSourceIdSplit[2];
            id_no = currSourceIdSplit[3]

            saveMarkers(exam_pk, pages_group_pk, copy_no, page_no, JSON.stringify(markerArea.getState()), markedImageDataUrl, sourceImage.getAttribute("src"), id_no);

            initCopyPagesTableOnClickRowEvent(true);
            currEl = document.getElementById(currSourceElementId)
            if (currEl) {
                currEl.style.backgroundColor = "yellow";
            }

        }

        function saveMarkers(pk, group_pk, copy_no, page_no, markers, marked_img_dataUrl, filename, curr_row) {
            $.ajax({
                url: "{% url 'save_markers' exam_selected.pk %}",
                type: "POST",
                data: {
                    'csrfmiddlewaretoken': "{{ csrf_token }}",
                    'reviewGroup_pk': group_pk,
                    'curr_row': curr_row,
                    'copy_no': copy_no,
                    'page_no': "" + page_no,
                    'markers': markers,
                    'marked_img_dataUrl': marked_img_dataUrl,
                    'filename': filename
                },
                beforeSend: function () {
                },
                success: (marked) => {
                    marked_info_element = document.getElementById(currSourceElementId + "_marked");
                    if (marked_info_element) {
                        marked_info_element.innerHTML = "";
                        if (marked === 'True') {
                            marked_info_element.innerHTML = '<i class="fa-solid fa-circle-check fa-lg" style="padding-left:25px;">';
                        }
                    }

                },
            });
        }

        function saveComment(data) {
            copy_no = currSourceIdSplit[1];

            // Convert pings to human readable format
            $(Object.keys(data.pings)).each(function (index, userId) {
                var fullname = data.pings[userId];
                var pingText = '@' + fullname;
                data.content = data.content.replace(new RegExp('@' + userId, 'g'), pingText);
            });

            $.ajax({
                url: "{% url 'save_comment' exam_selected.pk %}",
                type: "POST",
                async: false,
                data: {
                    'csrfmiddlewaretoken': "{{ csrf_token }}",
                    'comment': JSON.stringify(data),
                    'group_id': {{ pages_group.id }},
                    'copy_no': copy_no
                },
                success: (comment_id) => {
                    comments.slice(-1).id = comment_id;
                    data.id = comment_id;
                },
            });

            return data;
        }

        function deleteComment(data) {
            copy_no = currSourceIdSplit[1];

            $.ajax({
                url: "{% url 'save_comment' exam_selected.pk %}",
                type: "POST",
                async: false,
                data: {
                    'csrfmiddlewaretoken': "{{ csrf_token }}",
                    'comment_id': data.id,
                    'group_id': {{ pages_group.id }},
                    'copy_no': copy_no,
                    'delete': true
                },
                success: (deleted) => {
                    {#comments.slice(-1).id = comment_id;#}
                    {#data.id = comment_id;#}
                },
            });

            return data;
        }

        function initComments(commentsArray) {
            $('#comments-container').comments({
                profilePictureURL: 'fa-solid fa-circle-user fa-2xs',
                currentUserId: {{ user.id }},
                roundProfilePictures: true,
                textareaRows: 1,
                enableAttachments: false,
                enableHashtags: false,
                enableUpvoting: false,
                enableEditing: true,
                enableDeleting: true,
                scrollContainer: $(window),
                getComments: function (success, error) {
                    setTimeout(function () {
                        success(commentsArray);
                    }, 500);
                },
                postComment: function (data, success, error) {
                    setTimeout(function () {
                        success(saveComment(data));

                    }, 500);
                },
                putComment: function (data, success, error) {
                    setTimeout(function () {
                        success(saveComment(data));
                    }, 500);
                },
                deleteComment: function (data, success, error) {
                    setTimeout(function () {
                        success(deleteComment(data));

                    }, 500);
                },
            });
        }

        $(window).on("load", function () {
            initCopyPagesTableOnClickRowEvent(false);
            {% if currpage > 0 %}
                createPagination({{ copies_pages_list|length }}, {{ currpage }});
            {% else %}
                document.getElementById("copy_{{copies_pages_list.0.copy_no}}_{{copies_pages_list.0.page_no}}").click();
                setTimeout(() => {
                    document.getElementById("copy_{{copies_pages_list.0.copy_no}}_{{copies_pages_list.0.page_no}}").click()
                }, 350);
            {% endif %}

            SidebarCollapse();

            $('#reviewGroup_div').on('keydown', function (event) {
                switch (event.key) {
                    case "ArrowLeft":
                    case "ArrowUp":
                        previous_bt = document.getElementById('previous_page');
                        if (previous_bt != null) {
                            previous_bt.click();
                        }
                        break;
                    case "ArrowRight":
                    case "ArrowDown":
                        next_bt = document.getElementById('next_page');
                        if (next_bt != null) {
                            next_bt.click();
                        }
                        break;
                }
            }).focus();

        });

        document.getElementById("expandCollapseGroupListBt").addEventListener("click", function (event) {
            var expandIcon = $("#expand-group-list-icon");
            var collapseIcon = $("#collapse-group-list-icon");
            if (collapseIcon.hasClass('fa-angle-double-left')) {
                collapseIcon.removeClass('fa-angle-double-left');
                expandIcon.addClass("fa-solid fa-table-list")
                expandIcon.show();
                collapseIcon.hide();
            } else {
                expandIcon.removeClass('fa-solid fa-table-list');
                collapseIcon.addClass("fa-angle-double-left")
                collapseIcon.show();
                expandIcon.hide();
            }

        });

        //Magnifier
        function createDivMagnifier(elementID, zoom) {
            const elem = document.getElementById(elementID);

            // Create magnifier glass
            const glass = document.createElement("div");
            glass.classList.add("magnifier-glass");
            elem.parentElement.insertBefore(glass, elem);

            // Set background for the glass
            glass.style.backgroundImage = `url('${sourceImage.src}')`;
            glass.style.backgroundRepeat = "no-repeat";
            glass.style.backgroundSize = (markerArea.targetWidth  * zoom) + "px " + (markerArea.targetHeight * zoom) + "px";


            const bw = 3; // border width
            const w = glass.offsetWidth / 2;
            const h = glass.offsetHeight / 2;

            function moveMagnifier(e) {
                e.preventDefault();
                const pos = getCursorPos(e);
                let x = pos.x;
                let y = pos.y;

                // Keep the glass inside the image
                if (x > elem.width - w / zoom) x = elem.width - w / zoom;
                if (x < w / zoom) x = w / zoom;
                if (y > elem.height - h / zoom) y = elem.height - h / zoom;
                if (y < h / zoom) y = h / zoom;

                // Position the glass so its center is at the mouse pointer
                glass.style.left = (x - w) + "px";
                glass.style.top = (y - h) + "px";

                // Move the background so the area under the mouse is zoomed
                glass.style.backgroundPosition =
                    "-" + ((x * zoom) - w + bw) + "px " +
                    "-" + ((y * zoom) - h + bw) + "px";
            }

            function getCursorPos(e) {
                e = e || window.event;
                const rect = elem.getBoundingClientRect();
                const x = e.pageX - rect.left - window.pageXOffset;
                const y = e.pageY - rect.top - window.pageYOffset;
                return {x, y};
            }

            // Attach listeners (mouse + touch)
            elem.addEventListener("mousemove", moveMagnifier);
            elem.addEventListener("touchmove", moveMagnifier);

            // Optional: start glass at current mouse position if moving
            elem.addEventListener("mouseenter", (e) => moveMagnifier(e));

            // Return a function to clean up
            return function destroyMagnifier() {
                elem.removeEventListener("mousemove", moveMagnifier);
                elem.removeEventListener("touchmove", moveMagnifier);
                glass.remove();
            };
        }

        // Button toggles the magnifier
        document.getElementById("btn-magnify").addEventListener("click", function () {
            const btn = this;

            if (!magnifierActive) {
                destroyMagnifierFn = createDivMagnifier("marker-wrapper", 2); // 2 = zoom factor
                magnifierActive = true;

                document.getElementById("magnify-help").classList.remove("d-none");

                // Optional: change icon to show it's active
                const icon = btn.querySelector("i");
            } else {
                if (destroyMagnifierFn) destroyMagnifierFn();
                magnifierActive = false;

                document.getElementById("magnify-help").classList.add("d-none");

            }
        });

        // Outside click: disable magnifier if click is NOT inside the div or button
        document.addEventListener("click", function (e) {
            if (!magnifierActive) return; // nothing to do

            const zoomElem = document.getElementById("marker-wrapper");
            const btn = document.getElementById("btn-magnify");
            const clicked = e.target;

            // If click is inside the zoom div or on the button, ignore
            if (zoomElem.contains(clicked) || btn.contains(clicked)) {
                return;
            }

            // Otherwise: turn magnifier off
            if (destroyMagnifierFn) destroyMagnifierFn();
            magnifierActive = false;

            document.getElementById("magnify-help").classList.add("d-none");
        });

        {% if pages_group.use_grading_scheme %}
        function disableOtherSchemesExcept(activeId) {
            document.querySelectorAll('#review-scheme-pills .nav-link').forEach(a => {
                const id = a.id.replace('review-scheme-link-', '');
                if (id !== String(activeId)) {
                    a.classList.add('disabled');
                    a.setAttribute('aria-disabled', 'true');
                    a.setAttribute('tabindex', '-1');

                    // Add tooltip attrs
                    const usedLink = document.getElementById('review-scheme-link-' + activeId);
                    const usedName = usedLink ? usedLink.textContent.trim() : `#${activeId}`;

                    const msg = "This scheme can't be used because "+usedName+" is already used !";
                    a.parentNode.setAttribute('data-toggle', 'tooltip');
                    a.parentNode.setAttribute('data-placement', 'top');
                    a.parentNode.setAttribute('title', msg);

                    // Initialize (or update) Bootstrap tooltip
                    let tip = bootstrap.Tooltip.getInstance(a);
                    if (tip) {
                        tip.setContent({'.tooltip-inner': msg});
                    } else {
                        tip = new bootstrap.Tooltip(a);
                    }
                }
            });
        }

        function enableAllSchemes() {
            document.querySelectorAll('#review-scheme-pills .nav-link').forEach(a => {
                a.classList.remove('disabled');
                a.removeAttribute('aria-disabled');
                a.removeAttribute('tabindex');

                // Dispose tooltip cleanly
                const tip = bootstrap.Tooltip.getInstance(a);
                if (tip) tip.dispose();
                a.parentNode.removeAttribute('data-toggle');
                a.parentNode.removeAttribute('data-placement');
                a.parentNode.removeAttribute('title');
            });
        }

        function updatePagesGroupCheckBox(item_id, checked, adjustment,zero) {
            adjust_value = adjustment;
            //check if adjustment
            if (adjustment) {
                checkbox_id = item_id.replace('adj', 'check');
                checked = document.getElementById(checkbox_id).checked;
            } else {
                adjust_id = item_id.replace('check', 'adj');
                adjust_el = document.getElementById(adjust_id);
                if (adjust_el) {
                    adjust_value = adjust_el.value;
                }
            }

            $.ajax({
                url: "{% url 'update_pages_group_check_box' exam_selected.id %}",
                type: "POST",
                data: {
                    'csrfmiddlewaretoken': "{{ csrf_token }}",
                    'item_id': item_id,
                    'copy_nr': currSourceIdSplit[1],
                    'checked': checked,
                    'adjustment': adjust_value,
                    'pages_group_id': {{ pages_group.id }},
                    'grading_scheme_id': current_grading_scheme_id,
                    'zero': zero
                },
                success: (response) => {
                    if (response !== '') {
                        resp_data = JSON.parse(response);
                        corr_box_to_check = resp_data[0]
                        points = resp_data[1]
                        max_points = resp_data[2]

                        if (points !== '') {
                            maxPoints = Number(max_points);
                            points_content = Number(points).toFixed(2) + " / " + maxPoints.toFixed(2);
                            document.getElementById('gsc-points-'+current_grading_scheme_id).textContent = points_content;

                            if (Number(points) > 0){
                                disableOtherSchemesExcept(current_grading_scheme_id);
                            } else {
                                enableAllSchemes();
                            }
                        }

                        {#ici check zero#}
                        if(corr_box_to_check === -1){
                            createMarker4CorrBox(-1,-1,-1,-1);
                        }else {
                            const corr_boxes_polygons = document.querySelectorAll('#corrector_boxes_svg polygon');
                            const corr_box_to_click = corr_boxes_polygons[parseInt(corr_box_to_check)];
                            const pos = corr_box_to_click.getAttribute('data-bounds').split(',').map(Number);
                            createMarker4CorrBox(pos[0], pos[1], pos[2], pos[3]);
                        }
                        reloadGradingSchChkPanelHTMX(current_grading_scheme_id);
                    }
                }
            });
        }

        function reloadGradingSchChkPanelHTMX(gradingSchemeId) {
            const el = document.getElementById('chk-panel-' + gradingSchemeId);
            if (!el) return;
            const url = el.getAttribute('hx-get');
            htmx.ajax('GET', url, {target: el, swap: 'innerHTML'});
        }

        function sendScheme(el, evt) {
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }

            el.classList.add('active');
            el.setAttribute('aria-selected','true');
            const clickedId = el.id.replace('review-scheme-link-', '');

            var current = el.getAttribute('data-hx-get') || '';
            var copyNo = currSourceIdSplit[1];
            if (copyNo == null) return false;

            var updated = current.replace(/\/[^/?#]+(?=[?#]|$)/, '/' + encodeURIComponent(copyNo));
            el.setAttribute('data-hx-get', updated);

            // One-time listener for THIS swap; will fire after the panel HTML is inserted
            const onAfterSwap = (e) => {
                // Only react to the scheme panel swap
                if (!e.detail || !e.detail.target || e.detail.target.id !== 'review-scheme-panel') return;

                const usedId = e.detail.xhr && e.detail.xhr.getResponseHeader('X-Used-Grading-Scheme-Id');
                const activeId = usedId || el.id.replace('review-scheme-link-', '');
                current_grading_scheme_id = activeId;

                // toggle active state to the scheme the SERVER actually used
                document.querySelectorAll('#review-scheme-pills .nav-link').forEach(a => {
                  a.classList.remove('active');
                  a.setAttribute('aria-selected', 'false');
                });

                // disable other scheme if this one is used in checkboxes
                const points = e.detail.xhr.getResponseHeader('X-Points');
                if( points !== '' && points > 0) {
                    disableOtherSchemesExcept(usedId);
                }else{
                    enableAllSchemes();
                }

                const toActivate = document.getElementById('review-scheme-link-' + activeId);
                if (toActivate) {
                  toActivate.classList.add('active');
                  toActivate.setAttribute('aria-selected', 'true');
                }

                // optional: load the checkbox panel explicitly (if you’re not using hx-trigger="load once")
                const gsId   = activeId;                       // use the resolved scheme id
                const examId = el.getAttribute('data-exam-id');
                const chk    = document.getElementById('chk-panel-' + gsId);
                if (chk && examId) {
                  const chkUrl = `/review_grading_scheme_checkboxes/${examId}/${gsId}/${encodeURIComponent(copyNo)}`;
                  chk.setAttribute('hx-get', chkUrl);
                  htmx.ajax('GET', chkUrl, { target: chk, swap: 'innerHTML', source: chk });
                }

                // remove this one-time handler
                document.body.removeEventListener('htmx:afterSwap', onAfterSwap);
            };
            document.body.addEventListener('htmx:afterSwap', onAfterSwap);

            // Fire the request (no “active” toggle yet; we’ll do it in onAfterSwap)
            htmx.ajax('GET', updated, {
                target: '#review-scheme-panel',
                swap: 'innerHTML',
                source: el
            });

            return false;
        }

        /* Manage review grading scheme splittable divs */
        (function () {
            const MIN_TOP = 80;   // px
            const MIN_BOT = 120;  // px

            function initSplitters(root = document) {
                const splits = root.querySelectorAll('.review-grading-scheme-split-vert');
                splits.forEach(split => {
                    const handle = split.querySelector('.divider');
                    if (!handle) return;

                    // Avoid duplicate bindings if HTMX re-renders
                    if (handle.__splitBound) return;
                    handle.__splitBound = true;

                    let startY, startTop, maxTop;

                    const getY = (e) => ('touches' in e ? e.touches[0].clientY : e.clientY);
                    const px = (n) => `${n}px`;

                    function onDown(e) {
                        const rect = split.getBoundingClientRect();
                        startY = getY(e);

                        const cs = getComputedStyle(split);
                        const varTop = parseFloat(cs.getPropertyValue('--top')) || NaN;
                        const row0 = parseFloat(cs.gridTemplateRows.split(' ')[0]);
                        startTop = isNaN(varTop) ? row0 : varTop;

                        maxTop = rect.height - MIN_BOT - handle.offsetHeight;

                        document.body.classList.add('dragging');

                        window.addEventListener('mousemove', onMove, {passive: false});
                        window.addEventListener('touchmove', onMove, {passive: false});
                        window.addEventListener('mouseup', onUp, {once: true});
                        window.addEventListener('touchend', onUp, {once: true});

                        e.preventDefault();
                    }

                    function onMove(e) {
                        const dy = getY(e) - startY;
                        let newTop = Math.min(Math.max(startTop + dy, MIN_TOP), maxTop);
                        split.style.setProperty('--top', px(newTop));
                        e.preventDefault();
                    }

                    function onUp() {
                        document.body.classList.remove('dragging');
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('touchmove', onMove);
                    }

                    handle.addEventListener('mousedown', onDown);
                    handle.addEventListener('touchstart', onDown, {passive: false});
                });
            }

            // Initial
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => initSplitters());
            } else {
                initSplitters();
            }

            // Re-init when HTMX swaps your panel
            document.body.addEventListener('htmx:afterSwap', (evt) => {
                if (evt.target && evt.target.id === 'review-scheme-panel') {
                    // Rebind inside the swapped content
                    initSplitters(evt.target);
                }
            });
        })();
        {% endif %}
    </script>
    {% else %}
    <div class="alert alert-warning" role="alert" style="margin-top:20px;text-align:center;">No scans uploaded !</div>
    {% endif %}
{% endif %}
    {% endblock %}
