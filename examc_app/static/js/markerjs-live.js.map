{"version":3,"file":"markerjs-live.js","sources":["../src/core/SvgHelper.ts","../src/core/Activator.ts","../node_modules/tslib/tslib.es6.js","../src/core/MarkerBase.ts","../src/core/TransformMatrix.ts","../src/markers/RectangularBoxMarkerBase.ts","../src/markers/RectangleMarker.ts","../src/markers/frame-marker/FrameMarker.ts","../src/markers/LinearMarkerBase.ts","../src/markers/line-marker/LineMarker.ts","../src/markers/text-marker/TextMarker.ts","../src/markers/freehand-marker/FreehandMarker.ts","../src/markers/arrow-marker/ArrowMarker.ts","../src/markers/cover-marker/CoverMarker.ts","../src/markers/highlight-marker/HighlightMarker.ts","../src/markers/callout-marker/CalloutMarker.ts","../src/markers/ellipse-marker/EllipseMarker.ts","../src/markers/measurement-marker/MeasurementMarker.ts","../src/markers/ellipse-frame-marker/EllipseFrameMarker.ts","../src/markers/curve-marker/CurveMarker.ts","../src/markers/caption-frame-marker/CaptionFrameMarker.ts","../src/core/Style.ts","../src/core/Events.ts","../src/MarkerView.ts"],"sourcesContent":["/**\n * Utility class to simplify SVG operations.\n */\nexport class SvgHelper {\n  /**\n   * Creates SVG \"defs\".\n   */\n  public static createDefs(): SVGDefsElement {\n    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n\n    return defs;\n  }\n\n  /**\n   * Creates SVG stylesheet.\n   */\n  public static createStylesheet(): SVGStyleElement {\n    const stylesheet = document.createElementNS('http://www.w3.org/2000/svg', 'style');\n    stylesheet.setAttribute('type', 'text/css');\n\n    return stylesheet;\n  }\n\n  /**\n   * Sets attributes on an arbitrary SVG element\n   * @param el - target SVG element.\n   * @param attributes - set of name-value attribute pairs.\n   */\n  public static setAttributes(\n    el: SVGElement,\n    attributes: Array<[string, string]>\n  ): void {\n    for (const [attr, value] of attributes) {\n      el.setAttribute(attr, value);\n    }\n  }\n\n  /**\n   * Creates an SVG rectangle with the specified width and height.\n   * @param width \n   * @param height \n   * @param attributes - additional attributes.\n   */\n  public static createRect(\n    width: number | string,\n    height: number | string,\n    attributes?: Array<[string, string]>\n  ): SVGRectElement {\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n\n    rect.setAttribute('width', width.toString());\n    rect.setAttribute('height', height.toString());\n    if (attributes) {\n      SvgHelper.setAttributes(rect, attributes);\n    }\n\n    return rect;\n  }\n\n  /**\n   * Creates an SVG line with specified end-point coordinates.\n   * @param x1 \n   * @param y1 \n   * @param x2 \n   * @param y2 \n   * @param attributes - additional attributes.\n   */\n  public static createLine(\n    x1: number | string,\n    y1: number | string,\n    x2: number | string,\n    y2: number | string,\n    attributes?: Array<[string, string]>\n  ): SVGLineElement {\n    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n\n    line.setAttribute('x1', x1.toString());\n    line.setAttribute('y1', y1.toString());\n    line.setAttribute('x2', x2.toString());\n    line.setAttribute('y2', y2.toString());\n    if (attributes) {\n      SvgHelper.setAttributes(line, attributes);\n    }\n\n    return line;\n  }\n\n  /**\n   * Creates an SVG polygon with specified points.\n   * @param points - points as string.\n   * @param attributes - additional attributes.\n   */\n  public static createPolygon(\n    points: string,\n    attributes?: Array<[string, string]>\n  ): SVGPolygonElement {\n    const polygon = document.createElementNS(\n      'http://www.w3.org/2000/svg',\n      'polygon'\n    );\n\n    polygon.setAttribute('points', points);\n    if (attributes) {\n      SvgHelper.setAttributes(polygon, attributes);\n    }\n\n    return polygon;\n  }\n\n  /**\n   * Creates an SVG circle with the specified radius.\n   * @param radius \n   * @param attributes - additional attributes.\n   */\n  public static createCircle(\n    radius: number,\n    attributes?: Array<[string, string]>\n  ): SVGCircleElement {\n    const circle = document.createElementNS(\n      'http://www.w3.org/2000/svg',\n      'circle'\n    );\n\n    circle.setAttribute('cx', (radius / 2).toString());\n    circle.setAttribute('cy', (radius / 2).toString());\n    circle.setAttribute('r', radius.toString());\n    if (attributes) {\n      SvgHelper.setAttributes(circle, attributes);\n    }\n\n    return circle;\n  }\n\n  /**\n   * Creates an SVG ellipse with the specified horizontal and vertical radii.\n   * @param rx \n   * @param ry \n   * @param attributes - additional attributes.\n   */\n  public static createEllipse(\n    rx: number,\n    ry: number,\n    attributes?: Array<[string, string]>\n  ): SVGEllipseElement {\n    const ellipse = document.createElementNS(\n      'http://www.w3.org/2000/svg',\n      'ellipse'\n    );\n\n    ellipse.setAttribute('cx', (rx / 2).toString());\n    ellipse.setAttribute('cy', (ry / 2).toString());\n    ellipse.setAttribute('rx', (rx / 2).toString());\n    ellipse.setAttribute('ry', (ry / 2).toString());\n    if (attributes) {\n      SvgHelper.setAttributes(ellipse, attributes);\n    }\n\n    return ellipse;\n  }\n\n  /**\n   * Creates an SVG group.\n   * @param attributes - additional attributes.\n   */\n  public static createGroup(attributes?: Array<[string, string]>): SVGGElement {\n    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    if (attributes) {\n      SvgHelper.setAttributes(g, attributes);\n    }\n    return g;\n  }\n\n  /**\n   * Creates an SVG transform.\n   */\n  public static createTransform(): SVGTransform {\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n    return svg.createSVGTransform();\n  }\n\n  /**\n   * Creates an SVG marker.\n   * @param id \n   * @param orient \n   * @param markerWidth \n   * @param markerHeight \n   * @param refX \n   * @param refY \n   * @param markerElement \n   */\n  public static createMarker(\n    id: string,\n    orient: string,\n    markerWidth: number | string,\n    markerHeight: number | string,\n    refX: number | string,\n    refY: number | string,\n    markerElement: SVGGraphicsElement\n  ): SVGMarkerElement {\n    const marker = document.createElementNS(\n      'http://www.w3.org/2000/svg',\n      'marker'\n    );\n    SvgHelper.setAttributes(marker, [\n      ['id', id],\n      ['orient', orient],\n      ['markerWidth', markerWidth.toString()],\n      ['markerHeight', markerHeight.toString()],\n      ['refX', refX.toString()],\n      ['refY', refY.toString()],\n    ]);\n\n    marker.appendChild(markerElement);\n\n    return marker;\n  }\n\n  /**\n   * Creaes an SVG text element.\n   * @param attributes - additional attributes.\n   */\n  public static createText(\n    attributes?: Array<[string, string]>\n  ): SVGTextElement {\n    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    text.setAttribute('x', '0');\n    text.setAttribute('y', '0');\n\n    if (attributes) {\n      SvgHelper.setAttributes(text, attributes);\n    }\n\n    return text;\n  }\n\n  /**\n   * Creates an SVG TSpan.\n   * @param text - inner text.\n   * @param attributes - additional attributes.\n   */\n  public static createTSpan(\n    text: string,\n    attributes?: Array<[string, string]>\n  ): SVGTSpanElement {\n    const tspan = document.createElementNS(\n      'http://www.w3.org/2000/svg',\n      'tspan'\n    );\n    tspan.textContent = text;\n\n    if (attributes) {\n      SvgHelper.setAttributes(tspan, attributes);\n    }\n\n    return tspan;\n  }\n\n  /**\n   * Creates an SVG image element.\n   * @param attributes - additional attributes.\n   */\n  public static createImage(\n    attributes?: Array<[string, string]>\n  ): SVGImageElement {\n    const image = document.createElementNS(\n      'http://www.w3.org/2000/svg',\n      'image'\n    );\n\n    if (attributes) {\n      SvgHelper.setAttributes(image, attributes);\n    }\n\n    return image;\n  }\n\n  /**\n   * Creates an SVG point with the specified coordinates.\n   * @param x \n   * @param y \n   */\n  public static createPoint(      \n    x: number,\n    y: number\n  ): SVGPoint {\n      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      const svgPoint = svg.createSVGPoint();\n      svgPoint.x = x;\n      svgPoint.y = y;\n  \n      return svgPoint;\n  }\n\n  /**\n   * Creates an SVG path with the specified shape (d).\n   * @param d - path shape\n   * @param attributes - additional attributes.\n   */\n   public static createPath(\n    d: string,\n    attributes?: Array<[string, string]>\n  ): SVGPathElement {\n    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    path.setAttribute('d', d);\n    if (attributes) {\n      SvgHelper.setAttributes(path, attributes);\n    }\n\n    return path;\n  }\n}\n","/**\n * Manages commercial marker.js Live licenses.\n */\nexport class Activator {\n  private static key: string;\n\n  /**\n   * Add a license key\n   * @param key license key sent to you after purchase.\n   */\n  public static addKey(key: string): void {\n    Activator.key = key;\n  }\n\n  /**\n   * Returns true if the copy of marker.js Live is commercially licensed.\n   */\n  public static get isLicensed(): boolean {\n    // NOTE:\n    // before removing or modifying this please consider supporting marker.js\n    // by visiting https://markerjs.com/ for details\n    // thank you!\n    if (Activator.key) {\n      const keyRegex = new RegExp(/^MJSL-[A-Z][0-9]{3}-[A-Z][0-9]{3}-[0-9]{4}$/, 'i');\n      return keyRegex.test(Activator.key);\n    } else {\n      return false;\n    }\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { SvgHelper } from './SvgHelper';\nimport { IPoint } from './IPoint';\nimport { MarkerBaseState } from './MarkerBaseState';\n\n/**\n * Base class for all available and custom marker types.\n * \n * All markers used with marker.js Live should be descendants of this class.\n */\nexport class MarkerBase {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'MarkerBase';\n\n  protected _outerContainer: SVGGElement;\n  /**\n   * Outer SVG group container not manipulated or transformed by the marker itself in any way\n   */\n  public get outerContainer(): SVGGElement {\n    return this._outerContainer;\n  }\n\n  protected _container: SVGGElement;\n  /**\n   * SVG container object holding the marker's visual.\n   */\n  public get container(): SVGGElement {\n    return this._container;\n  }\n\n  /**\n   * Additional information about the marker\n   */\n  public notes?: string;\n\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title: string;\n\n  /**\n   * Method called when marker creation is finished.\n   */\n  public onMarkerCreated: (marker: MarkerBase) => void;\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    this._outerContainer = container;\n    const innerContainer = SvgHelper.createGroup();\n    this._outerContainer.appendChild(innerContainer);\n    this._container = innerContainer;\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ownsTarget(el: EventTarget): boolean {\n    return false;\n  }\n\n  /**\n   * Selects this marker.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public select(): void {}\n\n  /**\n   * Deselects this marker.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public deselect(): void {}\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n  public pointerDown(point: IPoint, target?: EventTarget):void {}\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) double click event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n  public dblClick(point: IPoint, target?: EventTarget):void {}\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) up event.\n   * \n   * @param point - event coordinates.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n  public pointerUp(point: IPoint):void {}\n\n  /**\n   * Disposes the marker and clean's up.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public dispose(): void {}\n\n  /**\n   * Adds marker's root visual element to the container group.\n   * @param element - marker's visual element.\n   */\n  protected addMarkerVisualToContainer(element: SVGElement): void {\n    if (this.container.childNodes.length > 0) {\n      this.container.insertBefore(element, this.container.childNodes[0]);\n    } else {\n      this.container.appendChild(element);\n    }\n  }\n\n  /**\n   * Restores previously saved marker state.\n   * \n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    this.notes = state.notes;\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   * \n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n  public scale(scaleX: number, scaleY: number): void {}\n}\n","/**\n * Represents a simplified version of the SVGMatrix.\n */\nexport interface ITransformMatrix {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  e: number;\n  f: number;\n}\n\n/**\n * A utility class to transform between SVGMatrix and its simplified representation.\n */\nexport class TransformMatrix {\n  public static toITransformMatrix(matrix: SVGMatrix): ITransformMatrix {\n    return {\n      a: matrix.a,\n      b: matrix.b,\n      c: matrix.c,\n      d: matrix.d,\n      e: matrix.e,\n      f: matrix.f\n    }\n  }\n  public static toSVGMatrix(currentMatrix: SVGMatrix, newMatrix: ITransformMatrix): SVGMatrix {\n    currentMatrix.a = newMatrix.a;\n    currentMatrix.b = newMatrix.b;\n    currentMatrix.c = newMatrix.c;\n    currentMatrix.d = newMatrix.d;\n    currentMatrix.e = newMatrix.e;\n    currentMatrix.f = newMatrix.f;\n    return currentMatrix;\n  }\n}","import { MarkerBase } from '../core/MarkerBase';\n\nimport { IPoint } from '../core/IPoint';\nimport { SvgHelper } from '../core/SvgHelper';\n\nimport { RectangularBoxMarkerBaseState } from './RectangularBoxMarkerBaseState';\nimport { MarkerBaseState } from '../core/MarkerBaseState';\nimport { TransformMatrix } from '../core/TransformMatrix';\n\n/**\n * RectangularBoxMarkerBase is a base class for all marker's with rectangular controls such as all rectangle markers,\n * text and callout markers.\n * \n * It creates and manages the rectangular control box and related resize, move, and rotate manipulations.\n */\nexport class RectangularBoxMarkerBase extends MarkerBase {\n  /**\n   * x coordinate of the top-left corner.\n   */\n  protected left = 0;\n  /**\n   * y coordinate of the top-left corner.\n   */\n  protected top = 0;\n  /**\n   * Marker width.\n   */\n  protected width = 0;\n  /**\n   * Marker height.\n   */\n  protected height = 0;\n\n  /**\n   * The default marker size when the marker is created with a click (without dragging).\n   */\n  protected defaultSize: IPoint = {x: 50, y: 20};\n\n  /**\n   * x coordinate of the top-left corner at the start of manipulation.\n   */\n  protected manipulationStartLeft: number;\n  /**\n   * y coordinate of the top-left corner at the start of manipulation.\n   */\n  protected manipulationStartTop: number;\n  /**\n   * Width at the start of manipulation.\n   */\n  protected manipulationStartWidth: number;\n  /**\n   * Height at the start of manipulation.\n   */\n  protected manipulationStartHeight: number;\n\n  /**\n   * x coordinate of the pointer at the start of manipulation.\n   */\n  protected manipulationStartX: number;\n  /**\n   * y coordinate of the pointer at the start of manipulation.\n   */\n  protected manipulationStartY: number;\n\n  /**\n   * Pointer's horizontal distance from the top left corner.\n   */\n  protected offsetX = 0;\n  /**\n   * Pointer's vertical distance from the top left corner.\n   */\n  protected offsetY = 0;\n\n  /**\n   * Marker's rotation angle.\n   */\n  protected rotationAngle = 0;\n\n  /**\n   * x coordinate of the marker's center.\n   */\n  protected get centerX(): number {\n    return this.left + this.width / 2;\n  }\n  /**\n   * y coordinate of the marker's center.\n   */\n  protected get centerY(): number {\n    return this.top + this.height / 2;\n  }\n\n  private _visual: SVGGraphicsElement;\n  /**\n   * Container for the marker's visual.\n   */\n  protected get visual(): SVGGraphicsElement {\n    return this._visual;\n  }\n  protected set visual(value: SVGGraphicsElement) {\n    this._visual = value;\n    const translate = SvgHelper.createTransform();\n    this._visual.transform.baseVal.appendItem(translate);\n  }\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    // add rotation transform\n    this.container.transform.baseVal.appendItem(SvgHelper.createTransform());\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (super.ownsTarget(el)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n\n    this.select();\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) up event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerUp(point: IPoint): void {\n    super.pointerUp(point);\n  }\n\n  /**\n   * Moves visual to the specified coordinates.\n   * @param point - coordinates of the new top-left corner of the visual.\n   */\n  protected moveVisual(point: IPoint): void {\n    this.visual.style.transform = `translate(${point.x}px, ${point.y}px)`;\n    // const translate = this.visual.transform.baseVal.getItem(0);\n    // translate.setTranslate(point.x, point.y);\n    // this.visual.transform.baseVal.replaceItem(translate, 0);\n  }\n\n  /**\n   * Resizes the marker based on pointer coordinates and context.\n   * @param point - pointer coordinates.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected resize(point: IPoint): void {\n    this.setSize();\n  }\n\n  /**\n   * Sets control box size and location.\n   */\n  protected setSize(): void {\n    this.moveVisual({x: this.left, y: this.top});\n  }\n\n  private rotate(point: IPoint) {\n    // avoid glitch when crossing the 0 rotation point\n    if (Math.abs(point.x - this.centerX) > 0.1) {\n      const sign = Math.sign(point.x - this.centerX);\n      this.rotationAngle =\n        (Math.atan((point.y - this.centerY) / (point.x - this.centerX)) * 180) /\n          Math.PI +\n        90 * sign;\n      this.applyRotation();\n    }\n  }\n\n  private applyRotation() {\n    const rotate = this.container.transform.baseVal.getItem(0);\n    rotate.setRotate(this.rotationAngle, this.centerX, this.centerY);\n    this.container.transform.baseVal.replaceItem(rotate, 0);\n  }\n\n  /**\n   * Returns point coordinates based on the actual screen coordinates and marker's rotation.\n   * @param point - original pointer coordinates\n   */\n  protected rotatePoint(point: IPoint): IPoint {\n    if (this.rotationAngle === 0) {\n      return point;\n    }\n    \n    const matrix = this.container.getCTM();\n    let svgPoint = SvgHelper.createPoint(point.x, point.y);\n    svgPoint = svgPoint.matrixTransform(matrix);\n\n    const result = { x: svgPoint.x, y: svgPoint.y };\n\n    return result;\n  }\n\n  /**\n   * Returns original point coordinates based on coordinates with rotation applied.\n   * @param point - rotated point coordinates.\n   */\n  protected unrotatePoint(point: IPoint): IPoint {\n    if (this.rotationAngle === 0) {\n      return point;\n    }\n    \n    let matrix = this.container.getCTM();\n    matrix = matrix.inverse();\n    let svgPoint = SvgHelper.createPoint(point.x, point.y);\n    svgPoint = svgPoint.matrixTransform(matrix);\n\n    const result = { x: svgPoint.x, y: svgPoint.y };\n\n    return result;\n  }\n\n  /**\n   * Displays marker's controls.\n   */\n  public select(): void {\n    super.select();\n  }\n\n  /**\n   * Hides marker's controls.\n   */\n  public deselect(): void {\n    super.deselect();\n  }\n\n  /**\n   * Restores marker's state to the previously saved one.\n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    super.restoreState(state);\n    const rbmState = state as RectangularBoxMarkerBaseState;\n    this.left = rbmState.left;\n    this.top = rbmState.top;\n    this.width = rbmState.width;\n    this.height = rbmState.height;\n    this.rotationAngle = rbmState.rotationAngle;\n    this.visual.transform.baseVal.getItem(0).setMatrix(\n      TransformMatrix.toSVGMatrix(this.visual.transform.baseVal.getItem(0).matrix, rbmState.visualTransformMatrix)\n    );\n    this.container.transform.baseVal.getItem(0).setMatrix(\n      TransformMatrix.toSVGMatrix(this.container.transform.baseVal.getItem(0).matrix, rbmState.containerTransformMatrix)\n    );\n    // this.moveVisual({x: this.left, y: this.top});\n    // this.applyRotation();\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   * \n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  public scale(scaleX: number, scaleY: number): void {\n    super.scale(scaleX, scaleY);\n\n    const rPoint = this.rotatePoint({x: this.left, y: this.top});\n    const point = this.unrotatePoint({x: rPoint.x * scaleX, y: rPoint.y * scaleY});\n\n    this.left = point.x;\n    this.top = point.y;\n    this.width = this.width * scaleX;\n    this.height = this.height * scaleY;\n  }\n\n}\n","import { IPoint } from '../core/IPoint';\nimport { SvgHelper } from '../core/SvgHelper';\nimport { RectangularBoxMarkerBase } from './RectangularBoxMarkerBase';\nimport { RectangleMarkerState } from './RectangleMarkerState';\nimport { MarkerBaseState } from '../core/MarkerBaseState';\n\n/**\n * RecatngleMarker is a base class for all rectangular markers (Frame, Cover, Highlight, etc.)\n */\nexport abstract class RectangleMarker extends RectangularBoxMarkerBase {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static title = 'Rectangle marker';\n\n  /**\n   * Recangle fill color.\n   */\n  protected fillColor = 'transparent';\n  /**\n   * Rectangle stroke color.\n   */\n  protected strokeColor = 'transparent';\n  /**\n   * Rectangle border stroke width.\n   */\n  protected strokeWidth = 0;\n  /**\n   * Rectangle border stroke dash array.\n   */\n  protected strokeDasharray = '';\n  /**\n   * Rectangle opacity (alpha). 0 to 1.\n   */\n  protected opacity = 1;\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.setStrokeColor = this.setStrokeColor.bind(this);\n    this.setFillColor = this.setFillColor.bind(this);\n    this.setStrokeWidth = this.setStrokeWidth.bind(this);\n    this.setStrokeDasharray = this.setStrokeDasharray.bind(this);\n    this.createVisual = this.createVisual.bind(this);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (super.ownsTarget(el) || el === this.visual) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Creates the marker's rectangle visual.\n   */\n  protected createVisual(): void {\n    this.visual = SvgHelper.createRect(1, 1, [\n      ['fill', this.fillColor],\n      ['stroke', this.strokeColor],\n      ['stroke-width', this.strokeWidth.toString()],\n      ['stroke-dasharray', this.strokeDasharray],\n      ['opacity', this.opacity.toString()]\n    ]);\n    this.addMarkerVisualToContainer(this.visual);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Resizes the marker based on the pointer coordinates.\n   * @param point - current pointer coordinates.\n   */\n  protected resize(point: IPoint): void {\n    super.resize(point);\n    this.setSize();\n  }\n\n  /**\n   * Sets visual's width and height attributes based on marker's width and height.\n   */\n  protected setSize(): void {\n    super.setSize();\n    SvgHelper.setAttributes(this.visual, [\n      ['width', this.width.toString()],\n      ['height', this.height.toString()],\n    ]);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) up event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerUp(point: IPoint): void {\n    super.pointerUp(point);\n    this.setSize();\n  }\n\n  /**\n   * Sets rectangle's border stroke color.\n   * @param color - color as string\n   */\n  protected setStrokeColor(color: string): void {\n    this.strokeColor = color;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['stroke', this.strokeColor]]);\n    }\n  }\n  /**\n   * Sets rectangle's fill color.\n   * @param color - color as string\n   */\n  protected setFillColor(color: string): void {\n    this.fillColor = color;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['fill', this.fillColor]]);\n    }\n  }\n  /**\n   * Sets rectangle's border stroke (line) width.\n   * @param color - color as string\n   */\n  protected setStrokeWidth(width: number): void {\n    this.strokeWidth = width;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['stroke-width', this.strokeWidth.toString()]]);\n    }\n  }\n  /**\n   * Sets rectangle's border stroke dash array.\n   * @param color - color as string\n   */\n  protected setStrokeDasharray(dashes: string): void {\n    this.strokeDasharray = dashes;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['stroke-dasharray', this.strokeDasharray]]);\n    }\n  }\n\n  /**\n   * Restores previously saved marker state.\n   * \n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    const rectState = state as RectangleMarkerState;\n    this.fillColor = rectState.fillColor;\n    this.strokeColor = rectState.strokeColor;\n    this.strokeWidth = rectState.strokeWidth;\n    this.strokeDasharray = rectState.strokeDasharray;\n    this.opacity = rectState.opacity;\n\n    this.createVisual();\n    super.restoreState(state);\n    this.setSize();\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   * \n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  public scale(scaleX: number, scaleY: number): void {\n    super.scale(scaleX, scaleY);\n\n    this.setSize();\n  }\n}\n","import { RectangleMarker } from '../RectangleMarker';\n\nexport class FrameMarker extends RectangleMarker {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'FrameMarker';\n  \n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Frame marker';\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n  }\n}\n","import { MarkerBase } from '../core/MarkerBase';\n\nimport { IPoint } from '../core/IPoint';\n\nimport { LinearMarkerBaseState } from './LinearMarkerBaseState';\nimport { MarkerBaseState } from '../core/MarkerBaseState';\n\n/**\n * LinearMarkerBase is a base class for all line-type markers (Line, Arrow, Measurement Tool, etc.).\n */\nexport class LinearMarkerBase extends MarkerBase {\n  /**\n   * x coordinate of the first end-point\n   */\n  protected x1 = 0;\n  /**\n   * y coordinate of the first end-point\n   */\n  protected y1 = 0;\n  /**\n   * x coordinate of the second end-point\n   */\n  protected x2 = 0;\n  /**\n   * y coordinate of the second end-point\n   */\n  protected y2 = 0;\n\n  /**\n   * Default line length when marker is created with a simple click (without dragging).\n   */\n  protected defaultLength = 50;\n\n  /**\n   * Marker's main visual.\n   */\n  protected visual: SVGGraphicsElement;\n\n  /**\n   * Creates a LineMarkerBase object.\n   * \n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (super.ownsTarget(el)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  \n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) up event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerUp(point: IPoint): void {\n    super.pointerUp(point);\n  }\n\n  /**\n   * When implemented adjusts marker visual after manipulation when needed.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  protected adjustVisual(): void {}\n\n  /**\n   * Resizes the line marker.\n   * @param point - current manipulation coordinates.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected resize(point: IPoint): void {\n    this.adjustVisual();\n  }\n\n  /**\n   * Displays marker's controls.\n   */\n  public select(): void {\n    super.select();\n  }\n\n  /**\n   * Hides marker's controls.\n   */\n  public deselect(): void {\n    super.deselect();\n  }\n\n  /**\n   * Restores marker's state to the previously saved one.\n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    super.restoreState(state);\n    const lmbState = state as LinearMarkerBaseState;\n    this.x1 = lmbState.x1;\n    this.y1 = lmbState.y1;\n    this.x2 = lmbState.x2;\n    this.y2 = lmbState.y2;\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   * \n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  public scale(scaleX: number, scaleY: number): void {\n    super.scale(scaleX, scaleY);\n\n    this.x1 = this.x1 * scaleX;\n    this.y1 = this.y1 * scaleY;\n    this.x2 = this.x2 * scaleX;\n    this.y2 = this.y2 * scaleY;\n\n    this.adjustVisual();\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { LinearMarkerBase } from '../LinearMarkerBase';\nimport { LineMarkerState } from './LineMarkerState';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\n\nexport class LineMarker extends LinearMarkerBase {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'LineMarker';\n  \n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Line marker';\n\n  /**\n   * Invisible wider line to make selection easier/possible.\n   */\n  protected selectorLine: SVGLineElement;\n  /**\n   * Visible marker line.\n   */\n  protected visibleLine: SVGLineElement;\n\n  /**\n   * Line color.\n   */\n  protected strokeColor = 'transparent';\n  /**\n   * Line width.\n   */\n  protected strokeWidth = 0;\n  /**\n   * Line dash array.\n   */\n  protected strokeDasharray = '';\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.setStrokeColor = this.setStrokeColor.bind(this);\n    this.setStrokeWidth = this.setStrokeWidth.bind(this);\n    this.setStrokeDasharray = this.setStrokeDasharray.bind(this);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (\n      super.ownsTarget(el) ||\n      el === this.visual ||\n      el === this.selectorLine ||\n      el === this.visibleLine\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private createVisual() {\n    this.visual = SvgHelper.createGroup();\n    this.selectorLine = SvgHelper.createLine(\n      this.x1,\n      this.y1,\n      this.x2,\n      this.y2,\n      [\n        ['stroke', 'transparent'],\n        ['stroke-width', (this.strokeWidth + 10).toString()],\n      ]\n    );\n    this.visibleLine = SvgHelper.createLine(\n      this.x1,\n      this.y1,\n      this.x2,\n      this.y2,\n      [\n        ['stroke', this.strokeColor],\n        ['stroke-width', this.strokeWidth.toString()],\n      ]\n    );\n    this.visual.appendChild(this.selectorLine);\n    this.visual.appendChild(this.visibleLine);\n\n    this.addMarkerVisualToContainer(this.visual);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Adjusts visual after manipulation.\n   */\n  protected adjustVisual(): void {\n    this.selectorLine.setAttribute('x1', this.x1.toString());\n    this.selectorLine.setAttribute('y1', this.y1.toString());\n    this.selectorLine.setAttribute('x2', this.x2.toString());\n    this.selectorLine.setAttribute('y2', this.y2.toString());\n\n    this.visibleLine.setAttribute('x1', this.x1.toString());\n    this.visibleLine.setAttribute('y1', this.y1.toString());\n    this.visibleLine.setAttribute('x2', this.x2.toString());\n    this.visibleLine.setAttribute('y2', this.y2.toString());\n\n    SvgHelper.setAttributes(this.visibleLine, [['stroke', this.strokeColor]]);\n    SvgHelper.setAttributes(this.visibleLine, [['stroke-width', this.strokeWidth.toString()]]);\n    SvgHelper.setAttributes(this.visibleLine, [['stroke-dasharray', this.strokeDasharray.toString()]]);\n  }\n\n  /**\n   * Sets line color.\n   * @param color - new color.\n   */\n  protected setStrokeColor(color: string): void {\n    this.strokeColor = color;\n    this.adjustVisual();\n  }\n  /**\n   * Sets line width.\n   * @param width - new width.\n   */\n  protected setStrokeWidth(width: number): void {\n    this.strokeWidth = width\n    this.adjustVisual();\n  }\n\n  /**\n   * Sets line dash array.\n   * @param dashes - new dash array.\n   */\n  protected setStrokeDasharray(dashes: string): void {\n    this.strokeDasharray = dashes;\n    this.adjustVisual();\n  }\n\n  /**\n   * Restores previously saved marker state.\n   * \n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    super.restoreState(state);\n\n    const lmState = state as LineMarkerState;\n    this.strokeColor = lmState.strokeColor;\n    this.strokeWidth = lmState.strokeWidth;\n    this.strokeDasharray = lmState.strokeDasharray;\n\n    this.createVisual();\n    this.adjustVisual();\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { RectangularBoxMarkerBase } from '../RectangularBoxMarkerBase';\nimport { TextMarkerState } from './TextMarkerState';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\n\nexport class TextMarker extends RectangularBoxMarkerBase {\n  /**\n   * String type name of the marker type.\n   *\n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'TextMarker';\n\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Text marker';\n\n  /**\n   * Text color.\n   */\n  protected color = 'transparent';\n  /**\n   * Text's font family.\n   */\n  protected fontFamily: string;\n  /**\n   * Padding inside of the marker's bounding box in percents.\n   */\n  protected padding = 5;\n\n  private text = '';\n\n  private wrapText = false;\n\n  /**\n   * Visual text element.\n   */\n  protected textElement: SVGTextElement;\n  /**\n   * Text background rectangle.\n   */\n  protected bgRectangle: SVGRectElement;\n\n  private pointerDownPoint: IPoint;\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.defaultSize = { x: 100, y: 30 };\n\n    this.setColor = this.setColor.bind(this);\n    this.setFont = this.setFont.bind(this);\n    this.renderText = this.renderText.bind(this);\n    this.sizeText = this.sizeText.bind(this);\n    this.setSize = this.setSize.bind(this);\n    this.getWrappedText = this.getWrappedText.bind(this);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   *\n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (\n      super.ownsTarget(el) ||\n      el === this.visual ||\n      el === this.textElement ||\n      el === this.bgRectangle\n    ) {\n      return true;\n    } else {\n      let found = false;\n      this.textElement.childNodes.forEach((span) => {\n        if (span === el) {\n          found = true;\n        }\n      });\n      return found;\n    }\n  }\n\n  /**\n   * Creates text marker visual.\n   */\n  protected createVisual(): void {\n    this.visual = SvgHelper.createGroup();\n\n    this.bgRectangle = SvgHelper.createRect(1, 1, [['fill', 'transparent']]);\n    this.visual.appendChild(this.bgRectangle);\n\n    this.textElement = SvgHelper.createText([\n      ['fill', this.color],\n      ['font-family', this.fontFamily],\n      ['font-size', '16px'],\n      ['x', '0'],\n      ['y', '0'],\n    ]);\n    this.textElement.transform.baseVal.appendItem(SvgHelper.createTransform()); // translate transorm\n    this.textElement.transform.baseVal.appendItem(SvgHelper.createTransform()); // scale transorm\n\n    this.visual.appendChild(this.textElement);\n\n    this.addMarkerVisualToContainer(this.visual);\n    this.renderText();\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   *\n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n\n    this.pointerDownPoint = point;\n  }\n\n  private getWrappedText(): string {\n    function getTextAspectRatio(textLines: string[]): number {\n      const charsLinesAspectRatio = 0.35;\n\n      let longestLineChars = textLines[0].length;\n      textLines.forEach(line => {\n        if (line.length > longestLineChars) {\n          longestLineChars = line.length;\n        }\n      });\n\n      return longestLineChars * charsLinesAspectRatio / textLines.length;\n    }\n\n    if (this.text !== '') {\n      const lines = this.text.split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/);\n      const boxAspectRatio = this.width * 1.0 / this.height;\n      let processedLines = new Array<string>(...lines);\n      \n      let textAspectRatio = getTextAspectRatio(processedLines);\n\n      let maxLineLength = Number.MAX_VALUE;\n      while (textAspectRatio > boxAspectRatio) {\n        let longestLine = processedLines[0];\n        processedLines.forEach(line => {\n          if (line.length > longestLine.length) {\n            longestLine = line;\n          }\n        });\n        maxLineLength = longestLine.lastIndexOf(' ', maxLineLength - 1);\n\n        if (maxLineLength > 0) {\n          processedLines = [];\n          lines.forEach(line => {\n            let reminderLine = line;\n            while (reminderLine.length > maxLineLength) {\n              let maxEnd = reminderLine.lastIndexOf(' ', maxLineLength);\n              if (maxEnd < 0) {\n                // if the first word is longer than max, at least wrap after it\n                maxEnd = reminderLine.indexOf(' ');\n              }\n              if (maxEnd > 0) {\n                processedLines.push(reminderLine.substring(0, maxEnd));\n                reminderLine = reminderLine.substring(maxEnd).trim();\n              } else {\n                processedLines.push(reminderLine);\n                reminderLine = '';\n              }\n            }\n            processedLines.push(reminderLine);\n          });\n          textAspectRatio = getTextAspectRatio(processedLines);\n        } else {\n          // can't wrap no more\n          textAspectRatio = -1;\n        }\n      }\n\n      return processedLines.join(`\\r\\n`);\n    } else {\n      return this.text;\n    }\n  }  \n\n  private renderText() {\n    const LINE_SIZE = '1.2em';\n\n    while (this.textElement.lastChild) {\n      this.textElement.removeChild(this.textElement.lastChild);\n    }\n\n    const processedText = this.wrapText ? this.getWrappedText() : this.text;\n    const lines = processedText.split(/\\r\\n|[\\n\\v\\f\\r\\x85\\u2028\\u2029]/);\n    lines.forEach((line) => {\n      this.textElement.appendChild(\n        SvgHelper.createTSpan(\n          // workaround for swallowed empty lines\n          line.trim() === '' ? ' ' : line.trim(), [\n          ['x', '0'],\n          ['dy', LINE_SIZE],\n        ])\n      );\n    });\n\n    setTimeout(this.sizeText, 10);\n  }\n\n  private getTextScale(): number {\n    const textSize = this.textElement.getBBox();\n    let scale = 1.0;\n    if (textSize.width > 0 && textSize.height > 0) {\n      const xScale =\n        (this.width * 1.0 - (this.width * this.padding * 2) / 100) /\n        textSize.width;\n      const yScale =\n        (this.height * 1.0 - (this.height * this.padding * 2) / 100) /\n        textSize.height;\n      scale = Math.min(xScale, yScale);\n    }\n    return scale;\n  }\n\n  private getTextPosition(scale: number): IPoint {\n    const textSize = this.textElement.getBBox();\n    let x = 0;\n    let y = 0;\n    if (textSize.width > 0 && textSize.height > 0) {\n      x = (this.width - textSize.width * scale) / 2;\n      y = this.height / 2 - (textSize.height * scale) / 2;\n    }\n    return { x: x, y: y };\n  }\n\n  private sizeText() {\n    const textBBox = this.textElement.getBBox();\n    const scale = this.getTextScale();\n    const position = this.getTextPosition(scale);\n    position.y -= textBBox.y * scale; // workaround adjustment for text not being placed at y=0\n\n    if (navigator.userAgent.indexOf('Edge/') > -1) {\n      // workaround for legacy Edge as transforms don't work otherwise but this way it doesn't work in Safari\n      this.textElement.style.transform = `translate(${position.x}px, ${position.y}px) scale(${scale}, ${scale})`;\n    } else {\n      this.textElement.transform.baseVal\n        .getItem(0)\n        .setTranslate(position.x, position.y);\n      this.textElement.transform.baseVal.getItem(1).setScale(scale, scale);\n    }\n  }\n\n  /**\n   * Resize marker based on current pointer coordinates and context.\n   * @param point\n   */\n  protected resize(point: IPoint): void {\n    super.resize(point);\n    this.setSize();\n    this.sizeText();\n  }\n\n  /**\n   * Sets size of marker elements after manipulation.\n   */\n  protected setSize(): void {\n    super.setSize();\n    SvgHelper.setAttributes(this.visual, [\n      ['width', this.width.toString()],\n      ['height', this.height.toString()],\n    ]);\n    SvgHelper.setAttributes(this.bgRectangle, [\n      ['width', this.width.toString()],\n      ['height', this.height.toString()],\n    ]);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) up event.\n   *\n   * @param point - event coordinates.\n   */\n  public pointerUp(point: IPoint): void {\n    super.pointerUp(point);\n    this.setSize();\n  }\n\n  /**\n   * Deselects this marker, renders text (if necessary), and hides selected marker UI.\n   */\n  public deselect(): void {\n    super.deselect();\n  }\n\n  /**\n   * Opens text editor on double-click.\n   * @param point\n   * @param target\n   */\n  public dblClick(point: IPoint, target?: EventTarget): void {\n    super.dblClick(point, target);\n  }\n\n  /**\n   * Sets text color.\n   * @param color - new text color.\n   */\n  protected setColor(color: string): void {\n    SvgHelper.setAttributes(this.textElement, [['fill', color]]);\n    this.color = color;\n  }\n\n  /**\n   * Sets font family.\n   * @param font - new font family.\n   */\n  protected setFont(font: string): void {\n    SvgHelper.setAttributes(this.textElement, [['font-family', font]]);\n    this.fontFamily = font;\n    this.renderText();\n  }\n\n  /**\n   * Restores previously saved marker state.\n   *\n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    const textState = state as TextMarkerState;\n    this.color = textState.color;\n    this.fontFamily = textState.fontFamily;\n    this.padding = textState.padding;\n    this.text = textState.text;\n    this.wrapText = textState.wrapText === true;\n\n    this.createVisual();\n    super.restoreState(state);\n    this.setSize();\n    if (this.wrapText) {\n      // need a rerender post setting size for wrapping\n      this.renderText();\n    }\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   *\n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  public scale(scaleX: number, scaleY: number): void {\n    super.scale(scaleX, scaleY);\n\n    this.setSize();\n    this.sizeText();\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { RectangularBoxMarkerBase } from '../RectangularBoxMarkerBase';\nimport { FreehandMarkerState } from './FreehandMarkerState';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\n\nexport class FreehandMarker extends RectangularBoxMarkerBase {\n  /**\n   * String type name of the marker type.\n   *\n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'FreehandMarker';\n\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Freehand marker';\n\n  /**\n   * Marker color.\n   */\n  protected color = 'transparent';\n  /**\n   * Marker's stroke width.\n   */\n  protected lineWidth = 3;\n\n  private drawingImage: SVGImageElement;\n  private drawingImgUrl: string;\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   *\n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (\n      super.ownsTarget(el) ||\n      el === this.visual ||\n      el === this.drawingImage\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private createVisual() {\n    this.visual = SvgHelper.createGroup();\n    this.drawingImage = SvgHelper.createImage();\n    this.visual.appendChild(this.drawingImage);\n\n    const translate = SvgHelper.createTransform();\n    this.visual.transform.baseVal.appendItem(translate);\n    this.addMarkerVisualToContainer(this.visual);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   *\n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Resize marker based on current pointer coordinates and context.\n   * @param point\n   */\n  protected resize(point: IPoint): void {\n    super.resize(point);\n    SvgHelper.setAttributes(this.visual, [\n      ['width', this.width.toString()],\n      ['height', this.height.toString()],\n    ]);\n    SvgHelper.setAttributes(this.drawingImage, [\n      ['width', this.width.toString()],\n      ['height', this.height.toString()],\n    ]);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) up event.\n   *\n   * @param point - event coordinates.\n   */\n  public pointerUp(point: IPoint): void {\n    super.pointerUp(point);\n  }\n\n  /**\n   * Selects this marker and displays appropriate selected marker UI.\n   */\n  public select(): void {\n    super.select();\n  }\n\n  /**\n   * Deselects this marker and hides selected marker UI.\n   */\n  public deselect(): void {\n    super.deselect();\n  }\n\n  private setDrawingImage() {\n    SvgHelper.setAttributes(this.drawingImage, [\n      ['width', this.width.toString()],\n      ['height', this.height.toString()],\n    ]);\n    SvgHelper.setAttributes(this.drawingImage, [['href', this.drawingImgUrl]]);\n    this.moveVisual({ x: this.left, y: this.top });\n  }\n\n  /**\n   * Restores previously saved marker state.\n   *\n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    this.createVisual();\n    super.restoreState(state);\n    this.drawingImgUrl = (state as FreehandMarkerState).drawingImgUrl;\n    this.setDrawingImage();\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   *\n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  public scale(scaleX: number, scaleY: number): void {\n    super.scale(scaleX, scaleY);\n\n    this.setDrawingImage();\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { LineMarker } from '../line-marker/LineMarker';\nimport { ArrowMarkerState, ArrowType } from './ArrowMarkerState';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\n\n/**\n * Represents an arrow marker.\n */\nexport class ArrowMarker extends LineMarker {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'ArrowMarker';\n\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Arrow marker';\n\n  private arrow1: SVGPolygonElement;\n  private arrow2: SVGPolygonElement;\n\n  private arrowType: ArrowType = 'end';\n\n  private arrowBaseHeight = 10;\n  private arrowBaseWidth = 10;\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.getArrowPoints = this.getArrowPoints.bind(this);\n    this.setArrowType = this.setArrowType.bind(this);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (\n      super.ownsTarget(el) ||\n      el === this.arrow1 || el === this.arrow2\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private getArrowPoints(offsetX: number, offsetY: number): string {\n    const width = this.arrowBaseWidth + this.strokeWidth * 2;\n    const height = this.arrowBaseHeight + this.strokeWidth * 2;\n    return `${offsetX - width / 2},${\n      offsetY + height / 2\n    } ${offsetX},${offsetY - height / 2} ${\n      offsetX + width / 2},${offsetY + height / 2}`;\n  }\n\n  private createTips() {\n    this.arrow1 = SvgHelper.createPolygon(this.getArrowPoints(this.x1, this.y1), [['fill', this.strokeColor]]);\n    this.arrow1.transform.baseVal.appendItem(SvgHelper.createTransform());\n    this.visual.appendChild(this.arrow1);\n\n    this.arrow2 = SvgHelper.createPolygon(this.getArrowPoints(this.x2, this.y2), [['fill', this.strokeColor]]);\n    this.arrow2.transform.baseVal.appendItem(SvgHelper.createTransform());\n    this.visual.appendChild(this.arrow2);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Adjusts marker visual after manipulation.\n   */\n  protected adjustVisual(): void {\n    super.adjustVisual();\n\n    if (this.arrow1 && this.arrow2) {\n      this.arrow1.style.display = (this.arrowType === 'both' || this.arrowType === 'start') ? '' : 'none';\n      this.arrow2.style.display = (this.arrowType === 'both' || this.arrowType === 'end') ? '' : 'none';\n\n      SvgHelper.setAttributes(this.arrow1, [\n        ['points', this.getArrowPoints(this.x1, this.y1)],\n        ['fill', this.strokeColor]\n      ]);\n      SvgHelper.setAttributes(this.arrow2, [\n        ['points', this.getArrowPoints(this.x2, this.y2)],\n        ['fill', this.strokeColor]\n      ]);\n\n      let lineAngle1 = 0;\n      if (Math.abs(this.x1 - this.x2) > 0.1) {\n        lineAngle1 =\n          (Math.atan((this.y2 - this.y1) / (this.x2 - this.x1)) * 180) / Math.PI + 90 * Math.sign(this.x1 - this.x2);\n      }\n\n      const a1transform = this.arrow1.transform.baseVal.getItem(0);\n      a1transform.setRotate(lineAngle1, this.x1, this.y1);\n      this.arrow1.transform.baseVal.replaceItem(a1transform, 0);\n\n      const a2transform = this.arrow2.transform.baseVal.getItem(0);\n      a2transform.setRotate(lineAngle1 + 180, this.x2, this.y2);\n      this.arrow2.transform.baseVal.replaceItem(a2transform, 0);\n    }\n  }\n\n  private setArrowType(arrowType: ArrowType) {\n    this.arrowType = arrowType;\n    this.adjustVisual();\n  }\n\n  /**\n   * Restores previously saved marker state.\n   * \n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    super.restoreState(state);\n\n    const amState = state as ArrowMarkerState;\n    this.arrowType = amState.arrowType;\n\n    this.createTips();\n    this.adjustVisual();\n  }\n\n}\n","import { RectangleMarker } from '../RectangleMarker';\n\nexport class CoverMarker extends RectangleMarker {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'CoverMarker';\n\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Cover marker';\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.strokeWidth = 0;\n  }\n}\n","import { CoverMarker } from '../cover-marker/CoverMarker';\nimport { SvgHelper } from '../../core/SvgHelper';\n\nexport class HighlightMarker extends CoverMarker {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'HighlightMarker';\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Highlight marker';\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.setOpacity = this.setOpacity.bind(this);\n\n    this.strokeWidth = 0;\n  }\n\n  /**\n   * Sets marker's opacity (0..1).\n   * @param opacity - new opacity value.\n   */\n  protected setOpacity(opacity: number): void {\n    this.opacity = opacity;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['opacity', this.opacity.toString()]]);\n    }\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { TextMarker } from '../text-marker/TextMarker';\nimport { CalloutMarkerState } from './CalloutMarkerState';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\n\nexport class CalloutMarker extends TextMarker {\n  /**\n   * String type name of the marker type.\n   *\n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'CalloutMarker';\n\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Callout marker';\n\n  private bgColor = 'transparent';\n\n  private tipPosition: IPoint = { x: 0, y: 0 };\n  private tipBase1Position: IPoint = { x: 0, y: 0 };\n  private tipBase2Position: IPoint = { x: 0, y: 0 };\n  private tip: SVGPolygonElement;\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.defaultSize = { x: 100, y: 30 };\n\n    this.setBgColor = this.setBgColor.bind(this);\n    this.getTipPoints = this.getTipPoints.bind(this);\n    this.positionTip = this.positionTip.bind(this);\n    this.setTipPoints = this.setTipPoints.bind(this);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   *\n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    return super.ownsTarget(el) || this.tip === el;\n  }\n\n  private createTip() {\n    SvgHelper.setAttributes(this.bgRectangle, [\n      ['fill', this.bgColor],\n      ['rx', '10px'],\n    ]);\n\n    this.tip = SvgHelper.createPolygon(this.getTipPoints(), [\n      ['fill', this.bgColor],\n    ]);\n    this.visual.appendChild(this.tip);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   *\n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) up event.\n   *\n   * @param point - event coordinates.\n   */\n  public pointerUp(point: IPoint): void {\n    super.pointerUp(point);\n  }\n\n  /**\n   * Sets marker's background/fill color.\n   * @param color - new background color.\n   */\n  protected setBgColor(color: string): void {\n    SvgHelper.setAttributes(this.bgRectangle, [['fill', color]]);\n    SvgHelper.setAttributes(this.tip, [['fill', color]]);\n    this.bgColor = color;\n  }\n\n  private getTipPoints(): string {\n    this.setTipPoints();\n    return `${this.tipBase1Position.x},${this.tipBase1Position.y} ${this.tipBase2Position.x},${this.tipBase2Position.y} ${this.tipPosition.x},${this.tipPosition.y}`;\n  }\n\n  private setTipPoints(isCreating = false) {\n    let offset = Math.min(this.height / 2, 15);\n    let baseWidth = this.height / 5;\n    if (isCreating) {\n      this.tipPosition = { x: offset + baseWidth / 2, y: this.height + 20 };\n    }\n\n    const cornerAngle = Math.atan(this.height / 2 / (this.width / 2));\n    if (\n      this.tipPosition.x < this.width / 2 &&\n      this.tipPosition.y < this.height / 2\n    ) {\n      // top left\n      const tipAngle = Math.atan(\n        (this.height / 2 - this.tipPosition.y) /\n          (this.width / 2 - this.tipPosition.x)\n      );\n      if (cornerAngle < tipAngle) {\n        baseWidth = this.width / 5;\n        offset = Math.min(this.width / 2, 15);\n        this.tipBase1Position = { x: offset, y: 0 };\n        this.tipBase2Position = { x: offset + baseWidth, y: 0 };\n      } else {\n        this.tipBase1Position = { x: 0, y: offset };\n        this.tipBase2Position = { x: 0, y: offset + baseWidth };\n      }\n    } else if (\n      this.tipPosition.x >= this.width / 2 &&\n      this.tipPosition.y < this.height / 2\n    ) {\n      // top right\n      const tipAngle = Math.atan(\n        (this.height / 2 - this.tipPosition.y) /\n          (this.tipPosition.x - this.width / 2)\n      );\n      if (cornerAngle < tipAngle) {\n        baseWidth = this.width / 5;\n        offset = Math.min(this.width / 2, 15);\n        this.tipBase1Position = { x: this.width - offset - baseWidth, y: 0 };\n        this.tipBase2Position = { x: this.width - offset, y: 0 };\n      } else {\n        this.tipBase1Position = { x: this.width, y: offset };\n        this.tipBase2Position = { x: this.width, y: offset + baseWidth };\n      }\n    } else if (\n      this.tipPosition.x >= this.width / 2 &&\n      this.tipPosition.y >= this.height / 2\n    ) {\n      // bottom right\n      const tipAngle = Math.atan(\n        (this.tipPosition.y - this.height / 2) /\n          (this.tipPosition.x - this.width / 2)\n      );\n      if (cornerAngle < tipAngle) {\n        baseWidth = this.width / 5;\n        offset = Math.min(this.width / 2, 15);\n        this.tipBase1Position = {\n          x: this.width - offset - baseWidth,\n          y: this.height,\n        };\n        this.tipBase2Position = { x: this.width - offset, y: this.height };\n      } else {\n        this.tipBase1Position = {\n          x: this.width,\n          y: this.height - offset - baseWidth,\n        };\n        this.tipBase2Position = { x: this.width, y: this.height - offset };\n      }\n    } else {\n      // bottom left\n      const tipAngle = Math.atan(\n        (this.tipPosition.y - this.height / 2) /\n          (this.width / 2 - this.tipPosition.x)\n      );\n      if (cornerAngle < tipAngle) {\n        baseWidth = this.width / 5;\n        offset = Math.min(this.width / 2, 15);\n        this.tipBase1Position = { x: offset, y: this.height };\n        this.tipBase2Position = { x: offset + baseWidth, y: this.height };\n      } else {\n        this.tipBase1Position = { x: 0, y: this.height - offset };\n        this.tipBase2Position = { x: 0, y: this.height - offset - baseWidth };\n      }\n    }\n  }\n\n  /**\n   * Resize marker based on current pointer coordinates and context.\n   * @param point\n   */\n  protected resize(point: IPoint): void {\n    super.resize(point);\n    this.positionTip();\n  }\n\n  private positionTip() {\n    SvgHelper.setAttributes(this.tip, [['points', this.getTipPoints()]]);\n  }\n\n  /**\n   * Selects this marker and displays appropriate selected marker UI.\n   */\n  public select(): void {\n    this.positionTip();\n    super.select();\n  }\n\n  /**\n   * Restores previously saved marker state.\n   *\n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    const calloutState = state as CalloutMarkerState;\n    this.bgColor = calloutState.bgColor;\n    this.tipPosition = calloutState.tipPosition;\n\n    super.restoreState(state);\n    this.createTip();\n    this.setTipPoints();\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   *\n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  public scale(scaleX: number, scaleY: number): void {\n    super.scale(scaleX, scaleY);\n\n    this.tipPosition = {\n      x: this.tipPosition.x * scaleX,\n      y: this.tipPosition.y * scaleY,\n    };\n\n    this.positionTip();\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { RectangularBoxMarkerBase } from '../RectangularBoxMarkerBase';\nimport { RectangleMarkerState } from '../RectangleMarkerState';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\n\nexport class EllipseMarker extends RectangularBoxMarkerBase {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'EllipseMarker';\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Ellipse marker';\n\n  /**\n   * Ellipse fill color.\n   */\n  protected fillColor = 'transparent';\n  /**\n   * Ellipse border color.\n   */\n  protected strokeColor = 'transparent';\n  /**\n   * Ellipse border line width.\n   */\n  protected strokeWidth = 0;\n  /**\n   * Ellipse border dash array.\n   */\n  protected strokeDasharray = '';\n  /**\n   * Ellipse opacity (0..1).\n   */\n  protected opacity = 1;\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.setStrokeColor = this.setStrokeColor.bind(this);\n    this.setFillColor = this.setFillColor.bind(this);\n    this.setStrokeWidth = this.setStrokeWidth.bind(this);\n    this.setStrokeDasharray = this.setStrokeDasharray.bind(this);\n    this.setOpacity = this.setOpacity.bind(this);\n    this.createVisual = this.createVisual.bind(this);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (super.ownsTarget(el) || el === this.visual) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Creates marker visual.\n   */\n  protected createVisual(): void {\n    this.visual = SvgHelper.createEllipse(this.width / 2, this.height / 2, [\n      ['fill', this.fillColor],\n      ['stroke', this.strokeColor],\n      ['stroke-width', this.strokeWidth.toString()],\n      ['stroke-dasharray', this.strokeDasharray],\n      ['opacity', this.opacity.toString()]\n    ]);\n    this.addMarkerVisualToContainer(this.visual);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Resize marker based on current pointer coordinates and context.\n   * @param point \n   */\n  protected resize(point: IPoint): void {\n    super.resize(point);\n    this.setSize();\n  }\n\n  /**\n   * Sets marker's visual size after manipulation.\n   */\n  protected setSize(): void {\n    super.setSize();\n    SvgHelper.setAttributes(this.visual, [\n      ['cx', (this.width / 2).toString()],\n      ['cy', (this.height / 2).toString()],\n      ['rx', (this.width / 2).toString()],\n      ['ry', (this.height / 2).toString()],\n    ]);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) up event.\n   * \n   * @param point - event coordinates.\n   */\n  public pointerUp(point: IPoint): void {\n    super.pointerUp(point);\n    this.setSize();\n  }\n\n  /**\n   * Sets marker's line color.\n   * @param color - new line color.\n   */\n  protected setStrokeColor(color: string): void {\n    this.strokeColor = color;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['stroke', this.strokeColor]]);\n    }\n  }\n  /**\n   * Sets marker's fill (background) color.\n   * @param color - new fill color.\n   */\n  protected setFillColor(color: string): void {\n    this.fillColor = color;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['fill', this.fillColor]]);\n    }\n  }\n  /**\n   * Sets marker's line width.\n   * @param width - new line width\n   */\n  protected setStrokeWidth(width: number): void {\n    this.strokeWidth = width;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['stroke-width', this.strokeWidth.toString()]]);\n    }\n  }\n  /**\n   * Sets marker's border dash array.\n   * @param dashes - new dash array.\n   */\n  protected setStrokeDasharray(dashes: string): void {\n    this.strokeDasharray = dashes;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['stroke-dasharray', this.strokeDasharray]]);\n    }\n  }\n  /**\n   * Sets marker's opacity.\n   * @param opacity - new opacity value (0..1).\n   */\n  protected setOpacity(opacity: number): void {\n    this.opacity = opacity;\n    if (this.visual) {\n      SvgHelper.setAttributes(this.visual, [['opacity', this.opacity.toString()]]);\n    }\n  }\n\n  /**\n   * Restores previously saved marker state.\n   * \n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    const rectState = state as RectangleMarkerState;\n    this.fillColor = rectState.fillColor;\n    this.strokeColor = rectState.strokeColor;\n    this.strokeWidth = rectState.strokeWidth;\n    this.strokeDasharray = rectState.strokeDasharray;\n    this.opacity = rectState.opacity;\n\n    this.createVisual();\n    super.restoreState(state);\n    this.setSize();\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   * \n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  public scale(scaleX: number, scaleY: number): void {\n    super.scale(scaleX, scaleY);\n\n    this.setSize();\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { LineMarker } from '../line-marker/LineMarker';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\n\nexport class MeasurementMarker extends LineMarker {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'MeasurementMarker';\n\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Measurement marker';\n\n  private tip1: SVGLineElement;\n  private tip2: SVGLineElement;\n\n  private get tipLength(): number {\n    return 10 + this.strokeWidth * 3;\n  }\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (\n      super.ownsTarget(el) ||\n      el === this.tip1 || el === this.tip2\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private createTips() {\n    this.tip1 = SvgHelper.createLine(\n      this.x1 - this.tipLength / 2, \n      this.y1, \n      this.x1 + this.tipLength / 2, \n      this.y1, \n      [\n        ['stroke', this.strokeColor],\n        ['stroke-width', this.strokeWidth.toString()]\n      ]);\n    this.tip1.transform.baseVal.appendItem(SvgHelper.createTransform());\n    this.visual.appendChild(this.tip1);\n\n    this.tip2 = SvgHelper.createLine(\n      this.x2 - this.tipLength / 2, \n      this.y2, \n      this.x2 + this.tipLength / 2, \n      this.y2, \n      [\n        ['stroke', this.strokeColor],\n        ['stroke-width', this.strokeWidth.toString()]\n      ]);\n    this.tip2.transform.baseVal.appendItem(SvgHelper.createTransform());\n    this.visual.appendChild(this.tip2);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Adjusts marker visual after manipulation.\n   */\n  protected adjustVisual(): void {\n    super.adjustVisual();\n\n    if (this.tip1 && this.tip2) {\n\n      SvgHelper.setAttributes(this.tip1,[\n        ['x1', (this.x1 - this.tipLength / 2).toString()], \n        ['y1', this.y1.toString()], \n        ['x2', (this.x1 + this.tipLength / 2).toString()], \n        ['y2', this.y1.toString()], \n        ['stroke', this.strokeColor],\n        ['stroke-width', this.strokeWidth.toString()]\n      ]);\n      SvgHelper.setAttributes(this.tip2,[\n        ['x1', (this.x2 - this.tipLength / 2).toString()], \n        ['y1', this.y2.toString()], \n        ['x2', (this.x2 + this.tipLength / 2).toString()], \n        ['y2', this.y2.toString()], \n        ['stroke', this.strokeColor],\n        ['stroke-width', this.strokeWidth.toString()]\n      ]);\n\n      if (Math.abs(this.x1 - this.x2) > 0.1) {\n        const lineAngle1 =\n          (Math.atan((this.y2 - this.y1) / (this.x2 - this.x1)) * 180) / Math.PI + 90 * Math.sign(this.x1 - this.x2);\n\n        const a1transform = this.tip1.transform.baseVal.getItem(0);\n        a1transform.setRotate(lineAngle1, this.x1, this.y1);\n        this.tip1.transform.baseVal.replaceItem(a1transform, 0);\n\n        const a2transform = this.tip2.transform.baseVal.getItem(0);\n        a2transform.setRotate(lineAngle1 + 180, this.x2, this.y2);\n        this.tip2.transform.baseVal.replaceItem(a2transform, 0);\n      }\n    }\n  }\n\n  /**\n   * Restores previously saved marker state.\n   * \n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    super.restoreState(state);\n\n    this.createTips();\n    this.adjustVisual();\n  }\n}\n","import { EllipseMarker } from '../ellipse-marker/EllipseMarker';\n\nexport class EllipseFrameMarker extends EllipseMarker {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'EllipseFrameMarker';\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Ellipse frame marker';\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.fillColor = 'transparent';\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { LinearMarkerBase } from '../LinearMarkerBase';\nimport { CurveMarkerState } from './CurveMarkerState';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\n\nexport class CurveMarker extends LinearMarkerBase {\n  /**\n   * String type name of the marker type. \n   * \n   * Used when adding {@link MarkerView.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'CurveMarker';\n  \n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Curve marker';\n  /**\n   * Invisible wider curve to make selection easier/possible.\n   */\n  protected selectorCurve: SVGPathElement;\n  /**\n   * Visible marker curve.\n   */\n  protected visibleCurve: SVGPathElement;\n\n  /**\n   * Line color.\n   */\n  protected strokeColor = 'transparent';\n  /**\n   * Line width.\n   */\n  protected strokeWidth = 0;\n  /**\n   * Line dash array.\n   */\n  protected strokeDasharray = '';\n\n  private curveX = 0;\n  private curveY = 0;\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   */\n  constructor(container: SVGGElement) {\n    super(container);\n\n    this.setStrokeColor = this.setStrokeColor.bind(this);\n    this.setStrokeWidth = this.setStrokeWidth.bind(this);\n    this.setStrokeDasharray = this.setStrokeDasharray.bind(this);\n    this.adjustVisual = this.adjustVisual.bind(this);\n    this.resize = this.resize.bind(this);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   * \n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (\n      super.ownsTarget(el) ||\n      el === this.visual ||\n      el === this.selectorCurve ||\n      el === this.visibleCurve\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  private getPathD(): string {\n    const result = `M ${this.x1} ${this.y1} Q ${this.curveX} ${this.curveY}, ${this.x2} ${this.y2}`;\n    return result;\n  }\n\n  private createVisual() {\n    this.visual = SvgHelper.createGroup();\n    this.selectorCurve = SvgHelper.createPath(\n      this.getPathD(),\n      [\n        ['stroke', 'transparent'],\n        ['stroke-width', (this.strokeWidth + 10).toString()],\n        ['fill', 'transparent'],\n      ]\n    );\n    this.visibleCurve = SvgHelper.createPath(\n      this.getPathD(),\n      [\n        ['stroke', this.strokeColor],\n        ['stroke-width', this.strokeWidth.toString()],\n        ['fill', 'transparent'],\n      ]\n    );\n    this.visual.appendChild(this.selectorCurve);\n    this.visual.appendChild(this.visibleCurve);\n\n    this.addMarkerVisualToContainer(this.visual);\n  }\n\n  /**\n   * Handles pointer (mouse, touch, stylus, etc.) down event.\n   * \n   * @param point - event coordinates.\n   * @param target - direct event target element.\n   */\n  public pointerDown(point: IPoint, target?: EventTarget): void {\n    super.pointerDown(point, target);\n  }\n\n  /**\n   * Adjusts visual after manipulation.\n   */\n  protected adjustVisual(): void {\n    this.selectorCurve.setAttribute('d', this.getPathD());\n\n    this.visibleCurve.setAttribute('d', this.getPathD());\n\n    SvgHelper.setAttributes(this.visibleCurve, [['stroke', this.strokeColor]]);\n    SvgHelper.setAttributes(this.visibleCurve, [['stroke-width', this.strokeWidth.toString()]]);\n    SvgHelper.setAttributes(this.visibleCurve, [['stroke-dasharray', this.strokeDasharray.toString()]]);\n  }\n\n  /**\n   * Sets line color.\n   * @param color - new color.\n   */\n  protected setStrokeColor(color: string): void {\n    this.strokeColor = color;\n    this.adjustVisual();\n  }\n  /**\n   * Sets line width.\n   * @param width - new width.\n   */\n  protected setStrokeWidth(width: number): void {\n    this.strokeWidth = width\n    this.adjustVisual();\n  }\n\n  /**\n   * Sets line dash array.\n   * @param dashes - new dash array.\n   */\n  protected setStrokeDasharray(dashes: string): void {\n    this.strokeDasharray = dashes;\n    this.adjustVisual();\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   * \n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n   public scale(scaleX: number, scaleY: number): void {\n    this.curveX = this.curveX * scaleX;\n    this.curveY = this.curveY * scaleY;\n    super.scale(scaleX, scaleY);\n  }\n\n  /**\n   * Restores previously saved marker state.\n   * \n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    super.restoreState(state);\n\n    const lmState = state as CurveMarkerState;\n    this.strokeColor = lmState.strokeColor;\n    this.strokeWidth = lmState.strokeWidth;\n    this.strokeDasharray = lmState.strokeDasharray;\n    this.curveX = lmState.curveX;\n    this.curveY = lmState.curveY;\n\n    this.createVisual();\n    this.adjustVisual();\n  }\n}\n","import { IPoint } from '../../core/IPoint';\nimport { SvgHelper } from '../../core/SvgHelper';\nimport { RectangularBoxMarkerBase } from '../RectangularBoxMarkerBase';\nimport { MarkerBaseState } from '../../core/MarkerBaseState';\nimport { CaptionFrameMarkerState } from './CaptionFrameMarkerState';\n\nexport class CaptionFrameMarker extends RectangularBoxMarkerBase {\n  /**\n   * String type name of the marker type.\n   *\n   * Used when adding {@link MarkerArea.availableMarkerTypes} via a string and to save and restore state.\n   */\n  public static typeName = 'CaptionFrameMarker';\n  /**\n   * Marker type title (display name) used for accessibility and other attributes.\n   */\n  public static title = 'Caption frame marker';\n  /**\n   * Caption background (fill) color.\n   */\n  protected fillColor = 'transparent';\n  /**\n   * Frame border color.\n   */\n  protected strokeColor = 'transparent';\n  /**\n   * Frame border line width.\n   */\n  protected strokeWidth = 0;\n  /**\n   * Frame border dash array.\n   */\n  protected strokeDasharray = '';\n  /**\n   * Caption font family.\n   */\n  protected fontFamily: string;\n  /**\n   * Caption text color.\n   */\n  protected textColor = 'transparent';\n  /**\n   * Caption font size.\n   */\n  protected fontSize = '1rem';\n\n  /**\n   * Frame rectangle.\n   */\n  protected frame: SVGRectElement;\n  /**\n   * Caption background element.\n   */\n  protected captionBg: SVGRectElement;\n  /**\n   * Caption text element.\n   */\n  protected captionElement!: SVGTextElement;\n  /**\n   * Caption text.\n   */\n  protected captionText = '';\n\n  /**\n   * Creates a new marker.\n   *\n   * @param container - SVG container to hold marker's visual.\n   * @param overlayContainer - overlay HTML container to hold additional overlay elements while editing.\n   * @param settings - settings object containing default markers settings.\n   */\n  constructor(\n    container: SVGGElement,\n  ) {\n    super(container);\n\n    this.createVisual = this.createVisual.bind(this);\n    this.sizeCaption = this.sizeCaption.bind(this);\n    this.setCaptionText = this.setCaptionText.bind(this);\n  }\n\n  /**\n   * Returns true if passed SVG element belongs to the marker. False otherwise.\n   *\n   * @param el - target element.\n   */\n  public ownsTarget(el: EventTarget): boolean {\n    if (\n      super.ownsTarget(el) ||\n      el === this.visual ||\n      el === this.frame ||\n      el === this.captionBg ||\n      el === this.captionElement\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Creates marker visual.\n   */\n  protected createVisual(): void {\n    this.visual = SvgHelper.createGroup();\n    this.addMarkerVisualToContainer(this.visual);\n\n    this.captionBg = SvgHelper.createRect(1, 1, [['fill', this.fillColor]]);\n    this.visual.appendChild(this.captionBg);\n\n    this.captionElement = SvgHelper.createText([\n      ['fill', this.textColor],\n      ['font-family', this.fontFamily],\n    ]);\n    this.captionElement.style.fontSize = this.fontSize;\n    this.captionElement.style.textAnchor = 'start';\n    this.captionElement.style.dominantBaseline = 'text-before-edge';\n    this.captionElement.textContent = this.captionText;\n    this.visual.appendChild(this.captionElement);\n\n    this.frame = SvgHelper.createRect(this.width, this.height, [\n      ['fill', 'transparent'],\n      ['stroke', this.strokeColor],\n      ['stroke-width', this.strokeWidth.toString()],\n      ['stroke-dasharray', this.strokeDasharray],\n    ]);\n\n    this.visual.appendChild(this.frame);\n    this.sizeCaption();\n  }\n\n  /**\n   * Sets caption text.\n   * @param text - new caption text.\n   */\n  public setCaptionText(text: string): void {\n    this.captionText = text;\n    this.captionElement.textContent = this.captionText;\n    this.sizeCaption();\n  }\n\n  /**\n   * Resize marker based on current pointer coordinates and context.\n   * @param point\n   */\n  protected resize(point: IPoint): void {\n    super.resize(point);\n    this.setSize();\n  }\n\n  private readonly PADDING = 5;\n  private captionBoxWidth = 0;\n  private captionBoxHeight = 0;\n  protected sizeCaption(): void {\n    const textBBox = this.captionElement.getBBox();\n    if (this.captionText.trim() !== '') {\n      this.captionBoxWidth = textBBox.width + this.PADDING * 2;\n      this.captionBoxHeight = textBBox.height + this.PADDING * 2;\n    } else {\n      this.captionBoxWidth = 0;\n      this.captionBoxHeight = 0;\n    }\n\n    SvgHelper.setAttributes(this.captionBg, [\n      ['width', this.captionBoxWidth.toString()],\n      ['height', this.captionBoxHeight.toString()],\n      [\n        'clip-path',\n        `path('M0,0 H${this.width} V${this.height} H${-this.width} Z')`,\n      ],\n    ]);\n    SvgHelper.setAttributes(this.captionElement, [\n      ['x', this.PADDING.toString()],\n      ['y', this.PADDING.toString()],\n      [\n        'clip-path',\n        `path('M0,0 H${this.width - this.PADDING} V${this.height} H${\n          -this.width - this.PADDING\n        } Z')`,\n      ],\n    ]);\n  }\n\n  /**\n   * Sets marker's visual size after manipulation.\n   */\n  protected setSize(): void {\n    super.setSize();\n    SvgHelper.setAttributes(this.frame, [\n      ['width', this.width.toString()],\n      ['height', this.height.toString()],\n    ]);\n    this.sizeCaption();\n  }\n\n  /**\n   * Restores previously saved marker state.\n   *\n   * @param state - previously saved state.\n   */\n  public restoreState(state: MarkerBaseState): void {\n    const frState = state as CaptionFrameMarkerState;\n    this.fillColor = frState.fillColor;\n    this.strokeColor = frState.strokeColor;\n    this.strokeWidth = frState.strokeWidth;\n    this.strokeDasharray = frState.strokeDasharray;\n    this.textColor = frState.textColor;\n    this.fontFamily = frState.fontFamily;\n    this.captionText = frState.captionText;\n    this.fontSize = frState.fontSize;\n\n    this.createVisual();\n    super.restoreState(state);\n    this.setSize();\n  }\n\n  /**\n   * Scales marker. Used after the image resize.\n   *\n   * @param scaleX - horizontal scale\n   * @param scaleY - vertical scale\n   */\n  public scale(scaleX: number, scaleY: number): void {\n    super.scale(scaleX, scaleY);\n\n    this.setSize();\n  }\n}\n","/**\n * Simple utility CSS-in-JS implementation.\n */\nexport class StyleManager {\n\n  private _classNamePrefixBase = '__markerjslive_';\n  /**\n   * Static CSS class name used for the wrapper element.\n   */\n   public get classNamePrefixBase(): string {\n    return this._classNamePrefixBase;\n  }\n\n  private _classNamePrefix: string;\n  /**\n   * Prefix used for all internally created CSS classes.\n   */\n  public get classNamePrefix(): string {\n    return this._classNamePrefix;\n  }\n\n  private classes: StyleClass[] = [];\n  private rules: StyleRule[] = [];\n  private styleSheet?: HTMLStyleElement;\n\n  /**\n   * For cases when you need to add the stylesheet to anything\n   * other than document.head (default), set this property\n   * before calling `show()`.\n   */\n  public styleSheetRoot: HTMLElement;\n\n  /**\n   * Initializes a new style manager.\n   * @param instanceNo - instance id.\n   */\n  constructor(instanceNo: number) {\n    this._classNamePrefix = `${this._classNamePrefixBase}_${instanceNo}_`;\n  }\n\n  /**\n   * Adds a CSS class declaration.\n   * @param styleClass - class to add.\n   */\n  public addClass(styleClass: StyleClass): StyleClass {\n    if (this.styleSheet === undefined) {\n      this.addStyleSheet();\n    }\n    styleClass.name = `${this.classNamePrefix}${styleClass.localName}`;\n    this.classes.push(styleClass);\n    this.styleSheet.sheet.insertRule(\n      `.${styleClass.name} {${styleClass.style}}`,\n      this.styleSheet.sheet.cssRules.length\n    );\n    return styleClass;\n  }\n\n  /**\n   * Add arbitrary CSS rule\n   * @param styleRule - CSS rule to add.\n   */\n  public addRule(styleRule: StyleRule): void {\n    if (this.styleSheet === undefined) {\n      this.addStyleSheet();\n    }\n    this.rules.push(styleRule);\n    // this.styleSheet.sheet.addRule(styleRule.selector, styleRule.style); // crashes in legacy Edge\n    this.styleSheet.sheet.insertRule(\n      `${styleRule.selector} {${styleRule.style}}`,\n      this.styleSheet.sheet.cssRules.length\n    );\n  }\n\n  private addStyleSheet() {\n    this.styleSheet = document.createElement('style');\n    (this.styleSheetRoot ?? document.head).appendChild(this.styleSheet);\n  }\n\n  public removeStyleSheet(): void {\n    if (this.styleSheet) {\n      (this.styleSheetRoot ?? document.head).removeChild(this.styleSheet);\n      this.styleSheet = undefined;\n    }\n  }\n}\n\n/**\n * Represents an arbitrary CSS rule.\n */\nexport class StyleRule {\n  /**\n   * CSS selector.\n   */\n  public selector: string;\n  /**\n   * Style declaration for the rule.\n   */\n  public style: string;\n  /**\n   * Creates an arbitrary CSS rule using the selector and style rules.\n   * @param selector - CSS selector\n   * @param style - styles to apply\n   */\n  constructor(selector: string, style: string) {\n    this.selector = selector;\n    this.style = style; \n  }\n}\n\n/**\n * Represents a CSS class.\n */\nexport class StyleClass {\n  /**\n   * CSS style rules for the class.\n   */\n  public style: string;\n  \n  /**\n   * Class name without the global prefix.\n   */\n  public localName: string;\n  /**\n   * Fully qualified CSS class name.\n   */\n  public name: string;\n\n  /**\n   * Creates a CSS class declaration based on supplied (local) name and style rules.\n   * @param name - local CSS class name (will be prefixed with the marker.js prefix).\n   * @param style - style declarations.\n   */\n  constructor(name: string, style: string) {\n    this.localName = name;\n    this.style = style; \n  }\n}\n","import { MarkerView } from '../MarkerView';\nimport { MarkerBase } from './MarkerBase';\n\n/**\n * General MarkerView event handler type.\n */\nexport type MarkerViewEventHandler = (markerView: MarkerView) => void;\n\n/**\n * Marker event handler type.\n */\nexport type MarkerEventHandler = (\n  markerView: MarkerView,\n  marker?: MarkerBase\n) => void;\n\n/**\n * Pointer related marker event handler type.\n */\nexport type PointerEventHandler = (\n  markerView: MarkerView,\n  event: PointerEvent,\n  marker?: MarkerBase\n) => void;\n\n/**\n * Describes a repository of MarkerView event handlers.\n */\nexport interface IEventListenerRepository {\n  /**\n   * Event handlers for the `create` event.\n   */\n  create: MarkerViewEventHandler[];\n  /**\n   * Event handlers for the `close` event.\n   */\n  close: MarkerViewEventHandler[];\n  /**\n   * Event handlers for the `load` event.\n   */\n  load: MarkerViewEventHandler[];\n  /**\n   * Event handlers for the `select` event.\n   */\n  select: MarkerEventHandler[];\n  /**\n   * Event handlers for the `over` event.\n   */\n  over: MarkerEventHandler[];\n  /**\n   * Event handlers for the `pointerdown` event.\n   */\n  pointerdown: PointerEventHandler[];\n  /**\n   * Event handlers for the `pointermove` event.\n   */\n  pointermove: PointerEventHandler[];\n  /**\n   * Event handlers for the `pointerup` event.\n   */\n  pointerup: PointerEventHandler[];\n  /**\n   * Event handlers for the `pointerenter` event.\n   */\n  pointerenter: PointerEventHandler[];\n  /**\n   * Event handlers for the `pointerleave` event.\n   */\n  pointerleave: PointerEventHandler[];\n}\n\n/**\n * Event handler type for a specific event type.\n */\nexport type EventHandler<\n  T extends keyof IEventListenerRepository\n> = T extends 'select'\n  ? MarkerEventHandler\n  : T extends 'over'\n  ? MarkerEventHandler\n  : T extends 'pointerdown'\n  ? PointerEventHandler\n  : T extends 'pointermove'\n  ? PointerEventHandler\n  : T extends 'pointerup'\n  ? PointerEventHandler\n  : T extends 'pointerenter'\n  ? PointerEventHandler\n  : T extends 'pointerleave'\n  ? PointerEventHandler\n  : MarkerViewEventHandler;\n\n/**\n * Event handler repository.\n */\nexport class EventListenerRepository implements IEventListenerRepository {\n  /**\n   * Event handlers for the `create` event.\n   */\n  create: MarkerViewEventHandler[] = [];\n  /**\n   * Event handlers for the `close` event.\n   */\n  close: MarkerViewEventHandler[] = [];\n  /**\n   * Event handlers for the `load` event.\n   */\n  load: MarkerViewEventHandler[] = [];\n  /**\n   * Event handlers for the `select` event.\n   */\n  select: MarkerEventHandler[] = [];\n  /**\n   * Event handlers for the `over` event.\n   */\n  over: MarkerEventHandler[] = [];\n  /**\n   * Event handlers for the `pointerdown` event.\n   */\n  pointerdown: PointerEventHandler[] = [];\n  /**\n   * Event handlers for the `pointermove` event.\n   */\n  pointermove: PointerEventHandler[] = [];\n  /**\n   * Event handlers for the `pointerup` event.\n   */\n  pointerup: PointerEventHandler[] = [];\n  /**\n   * Event handlers for the `pointerenter` event.\n   */\n  pointerenter: PointerEventHandler[] = [];\n  /**\n   * Event handlers for the `pointerleave` event.\n   */\n  pointerleave: PointerEventHandler[] = [];\n\n  /**\n   * Add an event handler for a specific event type.\n   * @param eventType - event type.\n   * @param handler - function to handle the event.\n   */\n  public addEventListener<T extends keyof IEventListenerRepository>(\n    eventType: T,\n    handler: EventHandler<T>\n  ): void {\n    (<Array<EventHandler<T>>>this[eventType]).push(handler);\n  }\n\n  /**\n   * Remove an event handler for a specific event type.\n   * @param eventType - event type.\n   * @param handler - function currently handling the event.\n   */\n  public removeEventListener<T extends keyof IEventListenerRepository>(\n    eventType: T,\n    handler: EventHandler<T>\n  ): void {\n    const index = (<Array<EventHandler<T>>>this[eventType]).indexOf(handler);\n    if (index > -1) {\n      (<Array<EventHandler<T>>>this[eventType]).splice(index, 1);\n    }\n  }\n}\n","import { SvgHelper } from './core/SvgHelper';\nimport { Activator } from './core/Activator';\n\nimport Logo from './assets/markerjs-logo-m.svg';\n\nimport { MarkerBase } from './core/MarkerBase';\nimport { FrameMarker } from './markers/frame-marker/FrameMarker';\nimport { LineMarker } from './markers/line-marker/LineMarker';\nimport { TextMarker } from './markers/text-marker/TextMarker';\nimport { FreehandMarker } from './markers/freehand-marker/FreehandMarker';\nimport { ArrowMarker } from './markers/arrow-marker/ArrowMarker';\nimport { CoverMarker } from './markers/cover-marker/CoverMarker';\nimport { HighlightMarker } from './markers/highlight-marker/HighlightMarker';\nimport { CalloutMarker } from './markers/callout-marker/CalloutMarker';\nimport { EllipseMarker } from './markers/ellipse-marker/EllipseMarker';\nimport { MeasurementMarker } from './markers/measurement-marker/MeasurementMarker';\nimport { EllipseFrameMarker } from './markers/ellipse-frame-marker/EllipseFrameMarker';\nimport { CurveMarker } from './markers/curve-marker/CurveMarker';\nimport { CaptionFrameMarker } from './markers/caption-frame-marker/CaptionFrameMarker';\n\nimport { MarkerAreaState } from './MarkerAreaState';\nimport { IPoint } from './core/IPoint';\n\nimport { StyleManager } from './core/Style';\nimport {\n  EventHandler,\n  EventListenerRepository,\n  IEventListenerRepository,\n} from './core/Events';\nimport { IMarkerViewPlugin } from './core/MarkerViewPlugin';\n\n/**\n * MarkerViews is the main class of marker.js Live. It controls the core behavior of the library.\n *\n * The simplest marker.js Live usage scenario looks something like this:\n *\n * ```typescript\n * // skip this line if you are importing marker.js Live into the global space via the script tag\n * import * as mjslive from 'markerjs-live';\n *\n * // create an instance of MarkerView and pass the target image reference as a parameter\n * const markerView = new mjslive.MarkerView(target);\n *\n * // call the show() method and pass your annotation configuration (created with marker.js 2) as a parameter\n * markerView.show(markerState);\n * ```\n */\nexport class MarkerView {\n  private target: HTMLElement;\n  private targetObserver: ResizeObserver;\n\n  private imageWidth: number;\n  private imageHeight: number;\n  private left: number;\n  private top: number;\n\n  public markerImage: SVGSVGElement;\n  private markerImageHolder: HTMLDivElement;\n  private defs: SVGDefsElement;\n\n  private coverDiv: HTMLDivElement;\n  private uiDiv: HTMLDivElement;\n  private contentDiv: HTMLDivElement;\n  private editorCanvas: HTMLDivElement;\n  private editingTarget: HTMLCanvasElement;\n  private overlayContainer: HTMLDivElement;\n\n  private touchPoints = 0;\n\n  private logoUI: HTMLElement;\n\n  private static instanceCounter = 0;\n  private _instanceNo: number;\n  /**\n   * Instance id of this instance\n   */\n  public get instanceNo(): number {\n    return this._instanceNo;\n  }\n\n  /**\n   * Manage style releated settings via the `styles` property.\n   */\n  public styles: StyleManager;\n\n  /**\n   * Marker types supported by this instance. \n   * You can remove some types to limit the markers displayed.\n   */\n  public availableMarkerTypes: typeof MarkerBase[] = [\n    FrameMarker,\n    FreehandMarker,\n    ArrowMarker,\n    TextMarker,\n    EllipseFrameMarker,\n    EllipseMarker,\n    HighlightMarker,\n    CalloutMarker,\n    MeasurementMarker,\n    CoverMarker,\n    LineMarker,\n    CurveMarker,\n    CaptionFrameMarker\n  ];\n\n  /**\n   * `targetRoot` is used to set an alternative positioning root.\n   *\n   * This is useful in cases when your target image is positioned, say, inside a div with `position: relative;`\n   *\n   * ```typescript\n   * // set targetRoot to a specific div instead of document.body\n   * markerView.targetRoot = document.getElementById('myRootElement');\n   * ```\n   *\n   * @default document.body\n   */\n  public targetRoot: HTMLElement;\n\n  private currentMarker?: MarkerBase;\n  private hoveredMarker?: MarkerBase;\n  /**\n   * The list of all markers displayed.\n   */\n  public markers: MarkerBase[] = [];\n\n  private isDragging = false;\n\n  private _isOpen = false;\n  /**\n   * Returns `true` when MarkerView is open and `false` otherwise.\n   *\n   * @readonly\n   */\n  public get isOpen(): boolean {\n    return this._isOpen;\n  }\n\n  private plugins: IMarkerViewPlugin[] = [];\n\n  /**\n   * The suffix of the CSS class name of the marker container (SVG group) element.\n   */\n  public readonly MARKER_CONTAINER_CLASS_SUFFIX = 'marker-container';\n\n  /**\n   * Creates a new MarkerView for the specified target image.\n   *\n   * ```typescript\n   * // create an instance of MarkerView and pass the target image reference as a parameter\n   * let markerView = new mjslive.MarkerView(document.getElementById('myimg'));\n   * ```\n   *\n   * @param target image object to be overlayed with markers.\n   */\n  constructor(target: HTMLElement) {\n    this._instanceNo = MarkerView.instanceCounter++;\n\n    this.styles = new StyleManager(this.instanceNo);\n\n    this.target = target;\n    this.targetRoot = document.body;\n\n    this.open = this.open.bind(this);\n    this.setTopLeft = this.setTopLeft.bind(this);\n\n    this.addNewMarker = this.addNewMarker.bind(this);\n    this.setCurrentMarker = this.setCurrentMarker.bind(this);\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onDblClick = this.onDblClick.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.onKeyUp = this.onKeyUp.bind(this);\n    this.close = this.close.bind(this);\n    this.closeUI = this.closeUI.bind(this);\n    this.clientToLocalCoordinates = this.clientToLocalCoordinates.bind(this);\n    this.onWindowResize = this.onWindowResize.bind(this);\n    this.removeMarker = this.removeMarker.bind(this);\n  }\n\n  private open(): void {\n    this.setupResizeObserver();\n    this.setEditingTarget();\n    this.setTopLeft();\n    this.initMarkerCanvas();\n    this.initOverlay();\n    this.attachEvents();\n\n    if (!Activator.isLicensed) {\n      // NOTE:\n      // before removing this call please consider supporting marker.js\n      // by visiting https://markerjs.com/ for details\n      // thank you!\n      this.addLogo();\n    }\n\n    this._isOpen = true;\n  }\n\n  /**\n   * Initializes the MarkerView and show the markers.\n   * \n   * @param state - marker configuration created with marker.js 2.\n   */\n  public show(state: MarkerAreaState): void {\n    this.showUI();\n    this.open();\n    \n    this.plugins.forEach(plugin => plugin.init(this));\n    \n    this.eventListeners['create'].forEach((created) => created(this));\n\n    this.restoreState(state);\n\n    this.eventListeners['load'].forEach((loaded) => loaded(this));\n  }\n\n  /**\n   * Closes the MarkerView.\n   */\n  public close(): void {\n    if (this.isOpen) {\n      if (this.coverDiv) {\n        this.closeUI();\n      }\n      if (this.targetObserver) {\n        this.targetObserver.unobserve(this.target);\n      }\n      this._isOpen = false;\n\n      this.eventListeners['close'].forEach(closed => closed(this));\n    }\n  }\n\n  private setupResizeObserver() {\n    if (window.ResizeObserver) {\n      this.targetObserver = new ResizeObserver(() => {\n        this.resize(this.target.clientWidth, this.target.clientHeight);\n      });\n      this.targetObserver.observe(this.target);\n    }\n  }\n\n  private resize(newWidth: number, newHeight: number) {\n    const scaleX = newWidth / this.imageWidth;\n    const scaleY = newHeight / this.imageHeight;\n\n    this.imageWidth = Math.round(newWidth);\n    this.imageHeight = Math.round(newHeight);\n    // this.editingTarget.src = this.target.src;\n    this.editingTarget.width = this.imageWidth;\n    this.editingTarget.height = this.imageHeight;\n    this.editingTarget.style.width = `${this.imageWidth}px`;\n    this.editingTarget.style.height = `${this.imageHeight}px`;\n\n    this.markerImage.setAttribute('width', this.imageWidth.toString());\n    this.markerImage.setAttribute('height', this.imageHeight.toString());\n    this.markerImage.setAttribute(\n      'viewBox',\n      '0 0 ' + this.imageWidth.toString() + ' ' + this.imageHeight.toString()\n    );\n\n    this.markerImageHolder.style.width = `${this.imageWidth}px`;\n    this.markerImageHolder.style.height = `${this.imageHeight}px`;\n\n    this.overlayContainer.style.width = `${this.imageWidth}px`;\n    this.overlayContainer.style.height = `${this.imageHeight}px`;\n\n    this.coverDiv.style.width = `${this.imageWidth.toString()}px`;\n\n    this.positionLogo();\n\n    this.scaleMarkers(scaleX, scaleY);\n  }\n\n  private scaleMarkers(scaleX: number, scaleY: number) {\n    let preScaleSelectedMarker: MarkerBase;\n    if (!(this.currentMarker && this.currentMarker instanceof TextMarker)) {\n      preScaleSelectedMarker = this.currentMarker;\n      this.setCurrentMarker();\n    }\n    this.markers.forEach((marker) => marker.scale(scaleX, scaleY));\n    if (preScaleSelectedMarker !== undefined) {\n      this.setCurrentMarker(preScaleSelectedMarker);\n    }\n  }\n\n  private setEditingTarget() {\n    this.imageWidth = Math.round(this.target.clientWidth);\n    this.imageHeight = Math.round(this.target.clientHeight);\n    // this.editingTarget.src = this.target.src;\n    this.editingTarget.width = this.imageWidth;\n    this.editingTarget.height = this.imageHeight;\n    this.editingTarget.style.width = `${this.imageWidth}px`;\n    this.editingTarget.style.height = `${this.imageHeight}px`;\n  }\n\n  private setTopLeft() {\n    const targetRect = this.editingTarget.getBoundingClientRect();\n    const bodyRect = this.editorCanvas.getBoundingClientRect();\n    this.left = targetRect.left - bodyRect.left;\n    this.top = targetRect.top - bodyRect.top;\n  }\n\n  private initMarkerCanvas(): void {\n    this.markerImageHolder = document.createElement('div');\n    this.markerImageHolder.style.setProperty('touch-action', 'pinch-zoom');\n\n    this.markerImage = document.createElementNS(\n      'http://www.w3.org/2000/svg',\n      'svg'\n    );\n    this.markerImage.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    this.markerImage.setAttribute('width', this.imageWidth.toString());\n    this.markerImage.setAttribute('height', this.imageHeight.toString());\n    this.markerImage.setAttribute(\n      'viewBox',\n      '0 0 ' + this.imageWidth.toString() + ' ' + this.imageHeight.toString()\n    );\n    this.markerImage.style.pointerEvents = 'auto';\n\n    this.markerImageHolder.style.position = 'absolute';\n    this.markerImageHolder.style.width = `${this.imageWidth}px`;\n    this.markerImageHolder.style.height = `${this.imageHeight}px`;\n    this.markerImageHolder.style.transformOrigin = 'top left';\n    this.positionMarkerImage();\n\n    this.defs = SvgHelper.createDefs();\n    this.markerImage.appendChild(this.defs);\n\n    this.markerImageHolder.appendChild(this.markerImage);\n\n    this.editorCanvas.appendChild(this.markerImageHolder);\n  }\n\n  private initOverlay(): void {\n    this.overlayContainer = document.createElement('div');\n    this.overlayContainer.style.position = 'absolute';\n    this.overlayContainer.style.left = '0px';\n    this.overlayContainer.style.top = '0px';\n    this.overlayContainer.style.width = `${this.imageWidth}px`;\n    this.overlayContainer.style.height = `${this.imageHeight}px`;\n    this.overlayContainer.style.display = 'flex';\n    this.markerImageHolder.appendChild(this.overlayContainer);\n  }\n\n  private positionMarkerImage() {\n    this.markerImageHolder.style.top = this.top + 'px';\n    this.markerImageHolder.style.left = this.left + 'px';\n  }\n\n  private attachEvents() {\n    this.markerImage.addEventListener('pointerdown', this.onPointerDown);\n    this.markerImage.addEventListener('dblclick', this.onDblClick);\n    window.addEventListener('pointermove', this.onPointerMove);\n    window.addEventListener('pointerup', this.onPointerUp);\n    window.addEventListener('pointercancel', () => {\n      if (this.touchPoints > 0) {\n        this.touchPoints--;\n      }\n    });\n    window.addEventListener('pointerout', () => {\n      if (this.touchPoints > 0) {\n        this.touchPoints--;\n      }\n    });\n    window.addEventListener('pointerleave', this.onPointerUp);\n    window.addEventListener('resize', this.onWindowResize);\n    window.addEventListener('keyup', this.onKeyUp);\n  }\n\n  /**\n   * NOTE:\n   *\n   * before removing or modifying this method please consider supporting marker.js\n   * by visiting https://markerjs.com/#price for details\n   *\n   * thank you!\n   */\n  private addLogo() {\n    this.logoUI = document.createElement('div');\n    this.logoUI.style.display = 'inline-block';\n    this.logoUI.style.margin = '0px';\n    this.logoUI.style.padding = '0px';\n    this.logoUI.style.fill = '#333333';\n\n    const link = document.createElement('a');\n    link.href = 'https://markerjs.com/';\n    link.target = '_blank';\n    link.innerHTML = Logo;\n    link.title = 'Powered by marker.js';\n\n    link.style.display = 'grid';\n    link.style.alignItems = 'center';\n    link.style.justifyItems = 'center';\n    link.style.padding = '3px';\n    link.style.width = '20px';\n    link.style.height = '20px';\n\n    this.logoUI.appendChild(link);\n\n    this.editorCanvas.appendChild(this.logoUI);\n\n    this.logoUI.style.position = 'absolute';\n    this.logoUI.style.pointerEvents = 'all';\n    this.positionLogo();\n  }\n\n  private positionLogo() {\n    if (this.logoUI) {\n      this.logoUI.style.left = `${this.markerImageHolder.offsetLeft + 10}px`;\n      this.logoUI.style.top = `${\n        this.markerImageHolder.offsetTop +\n        this.markerImageHolder.offsetHeight -\n        this.logoUI.clientHeight -\n        10\n      }px`;\n    }\n  }\n\n  private showUI(): void {\n    this.coverDiv = document.createElement('div');\n    this.coverDiv.className = `${this.styles.classNamePrefixBase} ${this.styles.classNamePrefix}`;\n    // hardcode font size so nothing inside is affected by higher up settings\n    this.coverDiv.style.fontSize = '16px';\n    this.coverDiv.style.userSelect = 'none';\n    this.coverDiv.style.position = 'absolute';\n    this.coverDiv.style.top = `${this.target.offsetTop.toString()}px`;\n    this.coverDiv.style.left = `${this.target.offsetLeft.toString()}px`;\n    this.coverDiv.style.width = `${this.target.offsetWidth.toString()}px`;\n    //this.coverDiv.style.height = `${this.target.offsetHeight.toString()}px`;\n    this.coverDiv.style.zIndex = '5';\n    // flex causes the ui to stretch when toolbox has wider nowrap panels\n    //this.coverDiv.style.display = 'flex';\n    this.targetRoot.appendChild(this.coverDiv);\n\n    this.uiDiv = document.createElement('div');\n    this.uiDiv.style.display = 'flex';\n    this.uiDiv.style.flexDirection = 'column';\n    this.uiDiv.style.flexGrow = '2';\n    this.uiDiv.style.margin = '0px';\n    this.uiDiv.style.border = '0px';\n    // this.uiDiv.style.overflow = 'hidden';\n    //this.uiDiv.style.backgroundColor = '#ffffff';\n    this.coverDiv.appendChild(this.uiDiv);\n\n    this.contentDiv = document.createElement('div');\n    this.contentDiv.style.display = 'flex';\n    this.contentDiv.style.flexDirection = 'row';\n    this.contentDiv.style.flexGrow = '2';\n    this.contentDiv.style.flexShrink = '1';\n    this.uiDiv.appendChild(this.contentDiv);\n\n    this.editorCanvas = document.createElement('div');\n    this.editorCanvas.style.flexGrow = '2';\n    this.editorCanvas.style.flexShrink = '1';\n    this.editorCanvas.style.position = 'relative';\n    this.editorCanvas.style.overflow = 'hidden';\n    this.editorCanvas.style.display = 'flex';\n    this.editorCanvas.style.pointerEvents = 'none';\n    this.contentDiv.appendChild(this.editorCanvas);\n\n    this.editingTarget = document.createElement('canvas');\n    this.editorCanvas.appendChild(this.editingTarget);\n  }\n\n  private closeUI() {\n    // @todo better cleanup\n    this.targetRoot.removeChild(this.coverDiv);\n  }\n\n  private removeMarker(marker: MarkerBase) {\n    this.markerImage.removeChild(marker.container);\n    if (this.markers.indexOf(marker) > -1) {\n      this.markers.splice(this.markers.indexOf(marker), 1);\n    }\n    marker.dispose();\n  }\n\n  /**\n   * Uses the state created with marker.js 2 to display the markers.\n   *\n   * @param state - previously saved marker.js 2 state object.\n   */\n  private restoreState(state: MarkerAreaState): void {\n    this.markers.splice(0);\n    while (this.markerImage.lastChild) {\n      this.markerImage.removeChild(this.markerImage.lastChild);\n    }\n    state.markers.forEach((markerState) => {\n      const markerType = this.availableMarkerTypes.find(\n        (mType) => mType.typeName === markerState.typeName\n      );\n      if (markerType !== undefined) {\n        const marker = this.addNewMarker(markerType);\n        marker.restoreState(markerState);\n        this.markers.push(marker);\n      }\n    });\n    if (\n      state.width &&\n      state.height &&\n      (state.width !== this.imageWidth || state.height !== this.imageHeight)\n    ) {\n      this.scaleMarkers(\n        this.imageWidth / state.width,\n        this.imageHeight / state.height\n      );\n    }\n  }\n\n  private addNewMarker(markerType: typeof MarkerBase): MarkerBase {\n    const g = SvgHelper.createGroup();\n    g.setAttribute('class', `${this.styles.classNamePrefix}${this.MARKER_CONTAINER_CLASS_SUFFIX}`);\n    this.markerImage.appendChild(g);\n\n    return new markerType(g);\n  }\n\n  /**\n   * Sets the currently selected marker or deselects it if no parameter passed.\n   *\n   * @param marker marker to select. Deselects current marker if undefined.\n   */\n  public setCurrentMarker(marker?: MarkerBase): void {\n    const currentChanged = this.currentMarker !== marker;\n\n    if (this.currentMarker !== undefined) {\n      this.currentMarker.deselect();\n    }\n    this.currentMarker = marker;\n    if (this.currentMarker !== undefined) {\n      this.currentMarker.select();\n    }\n\n    if (currentChanged) {\n      this.eventListeners['select'].forEach((selected) =>\n        selected(this, marker)\n      );\n    }\n  }\n\n  private onPointerDown(ev: PointerEvent) {\n    this.touchPoints++;\n    if (this.touchPoints === 1 || ev.pointerType !== 'touch') {\n      const hitMarker = this.markers.find((m) => m.ownsTarget(ev.target));\n      if (hitMarker !== undefined) {\n        this.setCurrentMarker(hitMarker);\n        this.isDragging = true;\n        this.currentMarker.pointerDown(\n          this.clientToLocalCoordinates(ev.clientX, ev.clientY),\n          ev.target\n        );\n      } else {\n        this.setCurrentMarker();\n      }\n\n      if (this.eventListeners['pointerdown'].length > 0) {\n        this.eventListeners['pointerdown'].forEach((pointerDownHandler) =>\n          pointerDownHandler(this, ev, hitMarker)\n        );\n      }\n    }\n  }\n\n  private onDblClick(ev: PointerEvent) {\n    const hitMarker = this.markers.find((m) => m.ownsTarget(ev.target));\n    if (hitMarker !== undefined && hitMarker !== this.currentMarker) {\n      this.setCurrentMarker(hitMarker);\n    }\n    if (this.currentMarker !== undefined) {\n      this.currentMarker.dblClick(\n        this.clientToLocalCoordinates(ev.clientX, ev.clientY),\n        ev.target\n      );\n    } else {\n      this.setCurrentMarker();\n    }\n  }\n\n  private isPointerIn = false;\n  private onPointerMove(ev: PointerEvent) {\n    if (this.touchPoints === 1 || ev.pointerType !== 'touch') {\n      if (\n        (this.currentMarker !== undefined && this.currentMarker.ownsTarget(ev.target)) || \n        this.isDragging\n        ) {\n        ev.preventDefault();\n      }\n    }\n\n    if (\n      this.eventListeners['over'].length > 0 ||\n      this.eventListeners['pointermove'].length > 0\n    ) {\n      const hitMarker = this.markers.find((m) => m.ownsTarget(ev.target));\n      if (hitMarker !== this.hoveredMarker) {\n        this.hoveredMarker = hitMarker;\n        this.eventListeners['over'].forEach((overHandler) =>\n          overHandler(this, this.hoveredMarker)\n        );\n      }\n\n      this.eventListeners['pointermove'].forEach((pointerMoveHandler) =>\n        pointerMoveHandler(this, ev, hitMarker)\n      );\n\n      if (!this.isPointerIn && (hitMarker !== undefined || this.markerImage === ev.target)) {\n        this.isPointerIn = true;\n        this.eventListeners['pointerenter'].forEach((pointerEnterHandler) =>\n          pointerEnterHandler(this, ev, hitMarker)\n        );\n      }\n\n      if (this.isPointerIn && hitMarker === undefined && this.markerImage !== ev.target) {\n        this.isPointerIn = false;\n        this.eventListeners['pointerleave'].forEach((pointerLeaveHandler) =>\n          pointerLeaveHandler(this, ev, hitMarker)\n        );\n      }\n    }\n  }\n\n  private onPointerUp(ev: PointerEvent) {\n    if (this.touchPoints > 0) {\n      this.touchPoints--;\n    }\n    if (this.touchPoints === 0) {\n      if (this.isDragging && this.currentMarker !== undefined) {\n        this.currentMarker.pointerUp(\n          this.clientToLocalCoordinates(ev.clientX, ev.clientY)\n        );\n      }\n    }\n    this.isDragging = false;\n\n    if (this.eventListeners['pointerup'].length > 0) {\n      const hitMarker = this.markers.find((m) => m.ownsTarget(ev.target));\n      this.eventListeners['pointerup'].forEach((pointerUpHandler) =>\n        pointerUpHandler(this, ev, hitMarker)\n      );\n    }\n\n  }\n\n  private onKeyUp(ev: KeyboardEvent) {\n    if (\n      this.currentMarker !== undefined &&\n      (ev.key === 'Delete' || ev.key === 'Backspace')\n    ) {\n      this.removeMarker(this.currentMarker);\n      this.setCurrentMarker();\n      this.markerImage.style.cursor = 'default';\n    }\n  }\n\n  private clientToLocalCoordinates(x: number, y: number): IPoint {\n    const clientRect = this.markerImage.getBoundingClientRect();\n    return { x: x - clientRect.left, y: y - clientRect.top };\n  }\n\n  private onWindowResize() {\n    this.positionUI();\n  }\n\n  private positionUI() {\n    this.setTopLeft();\n    this.coverDiv.style.top = `${this.target.offsetTop.toString()}px`;\n    this.coverDiv.style.left = `${this.target.offsetLeft.toString()}px`;\n    this.positionMarkerImage();\n    this.positionLogo();\n  }\n\n  private eventListeners = new EventListenerRepository();\n  /**\n   * Adds an event listener for one of the marker.js Live events.\n   * \n   * @param eventType - type of the event.\n   * @param handler - function handling the event.\n   */\n  public addEventListener<T extends keyof IEventListenerRepository>(\n    eventType: T,\n    handler: EventHandler<T>\n  ): void {\n    this.eventListeners.addEventListener(eventType, handler);\n  }\n\n  /**\n   * Removes an event listener for one of the marker.js Live events.\n   * \n   * @param eventType - type of the event.\n   * @param handler - function currently handling the event.\n   */\n  public removeEventListener<T extends keyof IEventListenerRepository>(\n    eventType: T,\n    handler: EventHandler<T>\n  ): void {\n    this.eventListeners.removeEventListener(eventType, handler);\n  }\n\n  /**\n   * Adds a plugin to the plugin array.\n   * @param plugin \n   */\n  public addPlugin(plugin: IMarkerViewPlugin): void {\n    this.plugins.push(plugin);\n  }\n  \n  /**\n   * Removes a plugin from the plugin array.\n   * @param plugin \n   */\n  public removePlugin(plugin: IMarkerViewPlugin): void {\n    const pluginIndex = this.plugins.indexOf(plugin);\n    if (pluginIndex >= 0) {\n      this.plugins.splice(pluginIndex, 1);\n    }\n  }\n}\n"],"names":["SvgHelper","document","createElementNS","stylesheet","setAttribute","el","attributes","attributes_1","_i","_a","attr","value","width","height","rect","toString","setAttributes","x1","y1","x2","y2","line","points","polygon","radius","circle","rx","ry","ellipse","g","createSVGTransform","id","orient","markerWidth","markerHeight","refX","refY","markerElement","marker","appendChild","text","tspan","textContent","image","x","y","svgPoint","createSVGPoint","d","path","Activator","key","Object","RegExp","test","extendStatics","b","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","container","_outerContainer","innerContainer","createGroup","_container","MarkerBase","point","target","element","childNodes","length","insertBefore","state","notes","scaleX","scaleY","TransformMatrix","matrix","a","c","e","f","currentMatrix","newMatrix","_super","_this","transform","baseVal","appendItem","createTransform","RectangularBoxMarkerBase","left","top","_visual","translate","ownsTarget","pointerDown","select","pointerUp","visual","style","setSize","moveVisual","Math","abs","centerX","sign","rotationAngle","atan","centerY","PI","applyRotation","rotate","getItem","setRotate","replaceItem","getCTM","createPoint","matrixTransform","inverse","deselect","restoreState","rbmState","setMatrix","toSVGMatrix","visualTransformMatrix","containerTransformMatrix","scale","rPoint","rotatePoint","unrotatePoint","setStrokeColor","bind","setFillColor","setStrokeWidth","setStrokeDasharray","createVisual","RectangleMarker","createRect","fillColor","strokeColor","strokeWidth","strokeDasharray","opacity","addMarkerVisualToContainer","resize","color","dashes","rectState","FrameMarker","LinearMarkerBase","adjustVisual","lmbState","LineMarker","selectorLine","visibleLine","createLine","lmState","defaultSize","setColor","setFont","renderText","sizeText","getWrappedText","TextMarker","textElement","bgRectangle","found_1","forEach","span","createText","fontFamily","pointerDownPoint","getTextAspectRatio","textLines","longestLineChars","lines","split","boxAspectRatio","processedLines_1","s","i","il","arguments","r","k","j","jl","textAspectRatio","maxLineLength_1","Number","MAX_VALUE","longestLine","lastIndexOf","reminderLine","maxEnd","indexOf","push","substring","trim","join","lastChild","removeChild","wrapText","createTSpan","setTimeout","textSize","getBBox","xScale","padding","yScale","min","textBBox","getTextScale","position","getTextPosition","navigator","userAgent","setTranslate","setScale","dblClick","font","textState","FreehandMarker","drawingImage","createImage","drawingImgUrl","setDrawingImage","getArrowPoints","setArrowType","ArrowMarker","arrow1","arrow2","offsetX","offsetY","arrowBaseWidth","arrowBaseHeight","createPolygon","display","arrowType","lineAngle1","a1transform","a2transform","amState","createTips","CoverMarker","setOpacity","HighlightMarker","setBgColor","getTipPoints","positionTip","setTipPoints","CalloutMarker","tip","bgColor","tipBase1Position","tipBase2Position","tipPosition","isCreating","offset","baseWidth","cornerAngle","calloutState","createTip","EllipseMarker","createEllipse","MeasurementMarker","tip1","tip2","tipLength","EllipseFrameMarker","CurveMarker","selectorCurve","visibleCurve","curveX","curveY","createPath","getPathD","sizeCaption","setCaptionText","CaptionFrameMarker","frame","captionBg","captionElement","textColor","fontSize","textAnchor","dominantBaseline","captionText","captionBoxWidth","PADDING","captionBoxHeight","frState","instanceNo","_classNamePrefix","_classNamePrefixBase","StyleManager","styleClass","undefined","styleSheet","addStyleSheet","name","classNamePrefix","localName","classes","sheet","insertRule","cssRules","styleRule","rules","selector","createElement","styleSheetRoot","head","EventListenerRepository","eventType","handler","index","splice","_instanceNo","MarkerView","instanceCounter","styles","targetRoot","body","open","setTopLeft","addNewMarker","setCurrentMarker","onPointerDown","onDblClick","onPointerMove","onPointerUp","onKeyUp","close","closeUI","clientToLocalCoordinates","onWindowResize","removeMarker","_isOpen","setupResizeObserver","setEditingTarget","initMarkerCanvas","initOverlay","attachEvents","isLicensed","addLogo","showUI","plugins","plugin","init","eventListeners","created","loaded","isOpen","coverDiv","targetObserver","unobserve","closed","window","ResizeObserver","clientWidth","clientHeight","observe","newWidth","newHeight","imageWidth","imageHeight","round","editingTarget","markerImage","markerImageHolder","overlayContainer","positionLogo","scaleMarkers","preScaleSelectedMarker","currentMarker","markers","targetRect","getBoundingClientRect","bodyRect","editorCanvas","setProperty","pointerEvents","transformOrigin","positionMarkerImage","defs","createDefs","addEventListener","touchPoints","logoUI","margin","fill","link","href","innerHTML","title","alignItems","justifyItems","offsetLeft","offsetTop","offsetHeight","className","classNamePrefixBase","userSelect","offsetWidth","zIndex","uiDiv","flexDirection","flexGrow","border","contentDiv","flexShrink","overflow","dispose","markerState","markerType","availableMarkerTypes","find","mType","typeName","MARKER_CONTAINER_CLASS_SUFFIX","currentChanged","selected","ev","pointerType","hitMarker_1","m","isDragging","clientX","clientY","pointerDownHandler","hitMarker","preventDefault","hitMarker_2","hoveredMarker","overHandler","pointerMoveHandler","isPointerIn","pointerEnterHandler","pointerLeaveHandler","hitMarker_3","pointerUpHandler","cursor","clientRect","positionUI","removeEventListener","pluginIndex"],"mappings":"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"}